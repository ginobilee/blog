<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mg20</title>
  
  <subtitle>知行合一</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://ginobilee.github.io/"/>
  <updated>2019-01-25T09:42:57.000Z</updated>
  <id>https://ginobilee.github.io/</id>
  
  <author>
    <name>mg20</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>我欲建立的知识结构模型</title>
    <link href="https://ginobilee.github.io/2019/01/25/%E6%88%91%E6%AC%B2%E5%BB%BA%E7%AB%8B%E7%9A%84%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ginobilee.github.io/2019/01/25/我欲建立的知识结构模型/</id>
    <published>2019-01-25T07:38:19.000Z</published>
    <updated>2019-01-25T09:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起源及程序员的一般知识结构"><a href="#起源及程序员的一般知识结构" class="headerlink" title="起源及程序员的一般知识结构"></a>起源及程序员的一般知识结构</h2><p>在跟踪winter的《重学前端》系列时的所想。  </p><p>winter提到，要建立自己的知识架构。这刚好是我最近在思考的问题。  </p><p>一个前端，首先是一个程序员。程序员的基本知识架构，前端也是应该具备的，比如数据结构、算法、编译原理、操作系统等等。但这些更是一个人的能力素质基础，虽然决定了一个人在技术上能够达到的高度，却不一定能在工作中立即解决面对的问题。这些素质我想可以认为是一个前端(以及程序员)在”道”这个层次的要求。而前端作为一个工程实践性远高于理论探索性的职业，从业者和招聘者也自然会忽视这方面的要求，而对具体的职业技能更为看重。  </p><p>大佬也提到这门课不会关注前面说的计算机基础，而是重点关注前端领域内的技能。我认为，在前端领域内，也可以划分为基础素质或曰能力，以及实践技能。基础素质按照大佬的这个划分已经是极好的了。javascript/html/css可以认为是前端从业者的工具，浏览器/node.js这些是前端工作的宿主，工程化是前端从业者利用工具在宿主上实现特定工程目标这一个过程的经验总结。这些可以认为是一个前端在”法”这个层次的要求。  </p><p>按照道、法、术的层次，现在社区中充斥的，”xx天带你撸一个xx”之类的文章或视频，基本上都是”术”这个层次。法与术，不同的人会有不同的见解。对于a来说认为是法的东西，可能对于b来说只是术，对于c来说已经是道了。我想这也能反映出一个人的认知水平。  </p><h2 id="javascript的知识结构"><a href="#javascript的知识结构" class="headerlink" title="javascript的知识结构"></a>javascript的知识结构</h2><p>具体到javascript这一块，我之前的认知将其从结构上分为这么两块: 语法+运行时。我所划分的语法就是指es规范，其实是大佬所讲的一整个javascript这块。而运行时是规范中implementation的概念，是浏览器(html标准)/node.js中对于规范的实现，以及这些特定实现中交织的其它(非es规范)部分。举例来说，大家经常提到的eventloop，其实是html或node.js中的机制，两者分别有对应的规范/实现。而在es规范中，其实只是在es6加入模块化和Promise之后才有相关的概念Job。而对于html规范中的eventloop，js的运行(脚本执行/多个JobQueue的执行)只是其中一部分，此外还有对于渲染的处理(resize/paint/requestAnimationFrame等等)。我觉得将这些概念区分清楚是大有裨益于自己知识结构的建立的，它们就像知识之间的边界，对于不同的知识有清晰的边界，才会有更清晰的认知。  </p><p>大佬将javascript的知识结构划分为 文法/语义/运行时 是一种更精准的划分。  </p><h2 id="我对于前端知识结构的认识"><a href="#我对于前端知识结构的认识" class="headerlink" title="我对于前端知识结构的认识"></a>我对于前端知识结构的认识</h2><p>我所认为的前端知识架构，其实从一个简单的问题就可以包括进来:一个页面从输入地址到可交互，有哪些过程？  </p><p>这个问题可以不停地深入下去，找到所有的细节；同时所有问题又都可以在这个问题上找到它的位置。比如从问题本身出发，牵涉到的问题就有:  </p><ol><li>网络。域名怎么转换为服务器地址?这里会不会有安全性问题？域名解析服务会不会挂掉(我们遇到过)?</li><li>http协议。一个请求的结构？缓存规则？service worker？动静分离？不同的状态码什么含义？跨域？动词方法？restful接口？预检请求？性能优化中相关措施？https？</li><li>浏览器的渲染过程。这是一个大的话题，里面信息量巨大。如何解析html？文档模型与渲染树？脚本的加载？如何优化脚本的加载？多个脚本加载有没有优化方法？为什么要以某种模式优化(比如script放在body后)？为什么处理js要阻塞渲染，浏览器为何如此设计，为何不像客户端一样分成两个线程？加载脚本的网络请求是同一个线程么？那多个脚本的加载是同一个线程么？脚本加载完后如何与渲染线程交互？把脚本放在html加载与放在另一个脚本里加载有区别么？js的模块化？要不要将多个请求分成多个域名，为什么？浏览器的事件循环模型？不同浏览器的兼容性？如何抹平差异？</li><li>页面的交互一般是通过js实现的，那么js的领域都可以牵涉进来了。<ol><li>js的语法和运行时</li><li>js可以访问到的宿主接口(这其实也是很大的一个范畴，比如setTimeout/setInterval都是其中的。而只是xhr/fetch就可以牵出许多问题。比如异步网络请求是在单独的线程执行的么？那么请求结果如何通知主线程？fetch请求会返回一个promise，那么它是放在Mircotask Queue的么？)</li><li>不同宿主对于js的实现？</li><li>es规范中的新语法？如何应用在没有提供实现的宿主中？<br>…</li></ol></li><li>内容结构和样式的组织: html与css。</li><li>站点结构。如何部署？如何最小更新？这里又牵涉到了工程化问题的一部分。<br>…</li></ol><p>回过头来，再将知识规划成上面这一个体系的话，可以将所有东西都划进对应的slot内。  </p><p>比如模块化，他应该是属于什么问题？它从一个工程问题而来(es规范最初没有模块化，只有社区的实践，require这样的语法在规范中是没有的)，演变成一个es规范的问题。而且我们可以看到，对于这个问题，es规范的解决是优于社区的解决方案的。规范的解决思路，是从语言的层面上去提供能力，社区的解决思路还是停留在解决问题。当然，规范的解决思路从社区中汲取了营养，这是毫无疑问的。   </p><p>总之，我想建立的知识体系，是对应这样一个流程的: 用这一个问题可以把所有这些概念包容进去；对于任何问题，又都可以在这个问题中找到它的坑位。   </p><h2 id="我想建立的知识结构"><a href="#我想建立的知识结构" class="headerlink" title="我想建立的知识结构"></a>我想建立的知识结构</h2><p>我想建立的是:  </p><ol><li>首先明白es规范对于问题是怎么阐述的。这里就包括 语法/算法。</li><li>各个宿主中是如何实现的。比如Promise，浏览器的实现？浏览器又是如何利用这些装置提供api的，比如fetch？</li><li>从第1个问题引申出的是js运行时的一个概览，明白从模块/函数到语句的运行过程；从第2个问题引申出的是浏览器或其它宿主是如何实现的？它们的内部架构？</li><li>明白了这两块，就基本明了了前端的基础。再辅以网络/更外层的宿主(浏览器可以认为是js宿主，操作系统可以认为是浏览器宿主，服务器可以认为是操作系统宿主)的原理，这个就是不断扩展边界的过程了。</li></ol><p>ref:    </p><ol><li><a href="https://time.geekbang.org/column/article/77749" target="_blank" rel="noopener">winter的分享之明确你的前端学习路线与方法</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起源及程序员的一般知识结构&quot;&gt;&lt;a href=&quot;#起源及程序员的一般知识结构&quot; class=&quot;headerlink&quot; title=&quot;起源及程序员的一般知识结构&quot;&gt;&lt;/a&gt;起源及程序员的一般知识结构&lt;/h2&gt;&lt;p&gt;在跟踪winter的《重学前端》系列时的所想。  &lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>myPromise</title>
    <link href="https://ginobilee.github.io/2019/01/24/myPromise/"/>
    <id>https://ginobilee.github.io/2019/01/24/myPromise/</id>
    <published>2019-01-24T14:18:06.000Z</published>
    <updated>2019-01-25T01:40:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>看了规范中阐述 <code>Promise</code> 时所用的数据结构和算法，才觉得自己的实现真是low爆了…</p><p>比如，为了在一个 <code>pending</code> 的promise (promiseA)的then方法中注册回调，同时返回一个新的Promise，我构造了一个 <code>FuturePromise</code> 结构。它的属性包括传入的 <code>onFullfill</code> 和 <code>onReject</code> ，以及一个 <code>cbs</code> 数组来存放它的回调。然后将这个 <code>FuturePromise</code> 对象push入 promiseA 的 <code>cbs</code> 数组中。<br>因为是返回了一个新的数据结构，所以也需要为这个类添加 <code>then</code> 方法。<br>反观规范中的实现，用 <code>PromiseCapability Record</code> 来作为 <code>Promise</code> 的容器，每次调用 <code>Promise</code> 构造器时，生成一个<code>PromiseCapability Record</code>，其中一个属性是返回的<code>promise</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;看了规范中阐述 &lt;code&gt;Promise&lt;/code&gt; 时所用的数据结构和算法，才觉得自己的实现真是low爆了…&lt;/p&gt;
&lt;p&gt;比如，为了在一个 &lt;code&gt;pending&lt;/code&gt; 的promise (promiseA)的then方法中注册回调，同时返回一个新的Pr
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Html</title>
    <link href="https://ginobilee.github.io/2019/01/24/html%E8%A7%84%E8%8C%83%E4%B8%AD%E7%9A%84eventloop%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ginobilee.github.io/2019/01/24/html规范中的eventloop运行模型/</id>
    <published>2019-01-24T11:17:41.000Z</published>
    <updated>2019-01-24T13:45:23.000Z</updated>
    
    <content type="html"><![CDATA[<p><code>eventloop</code>是一个经常被提起的话题。且经常以”讲下js中的eventloop”开始。要搞清楚这个问题，要把<code>js</code>分成两个部分: es规范和js运行时。es规范中阐述了运行时的一些规则，比如执行上下文栈，Promise等异步任务的处理；但不同的运行时，都可以实现自己的事件循环机制。比如，浏览器所依据的<code>html</code>规范中有对于事件循环模型的阐述，<code>node.js</code>中也有其自己的事件循环实现，两者并不相同。</p><h3 id="es规范中的-Job-模型"><a href="#es规范中的-Job-模型" class="headerlink" title="es规范中的 Job 模型"></a>es规范中的 Job 模型</h3><p>es规范中利用 Job 和 PendingJob 来阐述异步操作。比如 <code>Promise</code>，</p><blockquote><br>7.1.4.2. Processing model<br><br>An event loop must continually run through the following steps for as long as it exists:<br><br>1. Select the oldest task on one of the event loop’s task queues, if any, (ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active). The user agent may pick any task queue. If there is no task to select, then jump to the Microtasks step below.<br><br>    在该事件循环中寻找最早的task(可能来源于任意一个task队列。如果是浏览环境(<strong><em>注1</em></strong>)，忽略非active状态的Documents中的task)，如果没有，跳转到下面的Microtasks步。<br>2. Set the event loop’s currently running task to the task selected in the previous step.<br><br>    将该task设置为当前正在执行的task(crt)<br><br>3. Run: Run the selected task.<br><br>    执行该task<br><br>4. Set the event loop’s currently running task back to null.<br><br>    将crt设置为null<br><br>5. Remove the task that was run in the Run step above from its task queue.<br><br>    将该task从其task队列中移除<br><br>6. Microtasks: Perform a microtask checkpoint.<br><br>    执行微任务检查点<br><br>7. Update the rendering: If this event loop is a browsing context event loop (as opposed to a Worker event loop), then run the following substeps.<br><br>    更新渲染视图：如果是在浏览环境(而非worker环境)，执行下列分步骤：<br><br>    7.1 Let now be the value that would be returned by the Performance object’s now() method.  [HR-TIME-2]<br><br>    将now设置为Performance对象的now()方法将返回的时间点<br><br>    7.2 Let docs be the list of Document objects associated with the event loop in question, sorted arbitrarily except that the following conditions must be met:<br><br>    设置docs为当前event loop相关的所有Document对象的列表，可以为任意顺序但需满足以下要求:<br><br><br>        a. Any Document B that is nested through a Document A must be listed after A in the list.<br>        被Document A嵌套的任意Document B必须在A之后<br><br>        b. If there are two documents A and B whose browsing contexts are both nested browsing contexts and their browsing context containers are both elements in the same Document C, then the order of A and B in the list must match the relative tree order of their respective browsing context containers in C.<br>        如果两个Document A and B的浏览环境是同一个Document C的浏览环境下的某个节点的嵌套环境，则A and B在列表中的顺序应该与它们在C中的顺序保持一致<br><br>        In the steps below that iterate over docs, each Document must be processed in the order it is found in the list.<br>        在下面的步骤中，docs中的每个元素都应该以其所处位置顺序执行<br><br><br>    7.3 If there is a top-level browsing context B that the user agent believes would not benefit from having its rendering updated at this time, then remove from docs all Document objects whose browsing context’s top-level browsing context is B.<br><br>    如果ua(浏览器)认为某个顶级浏览环境B，不需要在当前时间点执行重新渲染，则将所有以其为顶级浏览环境的Document都移出列表<br><br>    Note:<br>    There are many factors that affect the ideal update frequency for the top-level browsing context including performance, power, background operation, quality of user experience, refresh rate of display(s), etc. When in foreground and not constrained by resources (i.e. performance, battery versus mains power, other resource limits), the user agent normally prioritizes for maximum quality of user experience for that set of Documents by matching update frequency and animation frame callback rate to the current refresh rate of the current display (usually 60Hz, but refresh rate may be higher or lower). When accommodating constraints on resources, the update frequency might automatically run at a lower rate. Also, if a top-level browsing context is in the background, the user agent might decide to drop that page to a much slower 4Hz, or even less.<br><br>    注意：<br>    有许多因素都会影响顶级浏览环境的理想刷新频率，比如性能，power，后台操作，用户体验质量，显示器更新频率等等。当页面处于前台且不受资源(如性能，电池等其它资源)所限，ua通常会以当前显示器的刷新频率来执行刷新和动画帧的回调，以达到最佳的用户体验。但当受资源限制时，更新频率通常会自动降低。同样，当一个顶级浏览环境处于后台，ua可能会将其更新降低至4Hz或更低。<br><br>    Note:<br>    Another example of why a browser might skip updating the rendering is to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). For example, a user agent might wish to coalesce callbacks together, with no intermediate rendering updates. However, when are no constraints on resources, there must not be an arbitrary permanent user agent limit on the update rate and animation frame callback rate (i.e., high refresh rate displays and/or low latency applications).<br><br>    注意：<br>    另外一个浏览器可能忽略掉渲染的场景时为了确保某些tasks能被无间断执行，其间只有微任务被执行(可能跳过了动画帧的回调)。例如，ua可能想要将回调合并在一起，中间没有渲染刷新。无论如何，当资源不受限制时，ua不应该有一个永久的最高或最低刷新频率界限。<br><br>    7.4 If there are a nested browsing contexts B that the user agent believes would not benefit from having their rendering updated at this time, then remove from docs all Document objects whose browsing context is in B.<br><br>    如果ua认为某个非顶级浏览环境B此时不需要刷新，将其所有子浏览环境从docs中移除。<br><br>    Note:<br>    As with top-level browsing contexts, a variety of factors can influence whether it is profitable for a browser to update the rendering of nested browsing contexts. For example, a user agent might wish to spend less resources rendering third-party content, especially if it is not currently visible to the user or if resources are constrained. In such cases, the browser could decide to update the rendering for such content infrequently or never.<br><br>    对于顶级浏览环境而言，有许多因素影响浏览器决定是否需要刷新其子环境。例如，ua可能希望在渲染第三方内容上投入较少的资源，尤其是当其在可视范围外或资源有限。这种情况下，浏览器可能会以极低的频率渲染这些内容，甚至永远不渲染。<br><br>    7.5 For each fully active Document in docs, run the resize steps for that Document, passing in now as the timestamp. [CSSOM-VIEW]<br><br>    遍历docs中有效的Document，执行resize操作，时间戳为now。[CSSOM构建]<br><br>    7.6 For each fully active Document in docs, run the scroll steps for that Document, passing in now as the timestamp. [CSSOM-VIEW]<br><br>    遍历docs中有效的Document，执行scroll操作，时间戳为now。[CSSOM构建]<br><br>    7.7 For each fully active Document in docs, evaluate media queries and report changes for that Document, passing in now as the timestamp. [CSSOM-VIEW]<br><br>    遍历docs中有效的Document，执行媒体查询并报告变化，时间戳为now。[CSSOM构建]<br><br>    7.8 For each fully active Document in docs, run CSS animations and send events for that Document, passing in now as the timestamp. [CSS3-ANIMATIONS]<br><br>    遍历docs中有效的Document，执行css动画并发送事件，时间戳为now。[CSSOM构建]<br><br>    7.9 For each fully active Document in docs, run the fullscreen rendering steps for that Document, passing in now as the timestamp. [FULLSCREEN]<br><br>    遍历docs中有效的Document，执行全屏渲染，时间戳为now。[CSSOM构建]<br><br><br>    7.10 For each fully active Document in docs, run the animation frame callbacks for that Document, passing in now as the timestamp.<br><br>    遍历docs中有效的Document，执行动画帧回调(<strong><em>注2</em></strong>)，时间戳为now。[CSSOM构建]<br><br>    7.11 For each fully active Document in docs, update the rendering or user interface of that Document and its browsing context to reflect the current state.<br><br>    遍历docs中有效的Document，根据其当前状态，更新这个Document及其浏览环境的渲染或ui<br><br>8. If this is a Worker event loop (i.e., one running for a WorkerGlobalScope), but there are no tasks in the event loop’s task queues and the WorkerGlobalScope object’s closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps.<br><br>    如果是Worker的event loop，但是其task队列中无任务了，且WorkerGlobalScope对象的closing标志是true，则销毁此event loop，跳出循环，恢复run a worker操作。<br><br>9. Return to the first step of the event loop.<br><br>    返回当前event loop的第一步。<br></blockquote><p>注释: </p><ol><li>browsing contexts是什么？</li></ol><blockquote><br>A browsing context is an environment in which Document objects are presented to the user.<br><br>&gt; Note:<br>&gt;<br>&gt; A tab or window in a Web browser typically contains a browsing context, as does an iframe or frames in a frameset.<br><br>A browsing context has a corresponding WindowProxy object.<br><br>A browsing context has a session history, which lists the Document objects that the browsing context has presented, is presenting, or will present. At any time, one Document in each browsing context is designated the active document. A Document’s browsing context is that browsing context whose session history contains the Document, if any. (A Document created using an API such as createDocument() has no browsing context.) Each Document in a browsing context is associated with a Window object.<br></blockquote><ol start="2"><li><p>即通过requestAnimationFrame设置的回调。见html规范7.9. Animation Frames中。</p></li><li><p>what’s WindowProxy?</p><p> A WindowProxy is an exotic object that wraps a Window ordinary object, indirecting most operations through to the wrapped object. Each browsing context has an associated WindowProxy object. <strong>When the browsing context is navigated, the Window object wrapped by the browsing context’s associated WindowProxy object is changed.</strong></p><p> Every WindowProxy object has a [[Window]] internal slot representing the wrapped Window object.</p></li><li><p>es规范从几开始有 Job 的？比如 scriptjob???</p></li></ol><p>【ref】: </p><p><a href="https://www.w3.org/TR/html52/webappapis.html#event-loops-processing-model" target="_blank" rel="noopener">https://www.w3.org/TR/html52/webappapis.html#event-loops-processing-model</a></p><p><a href="https://www.w3.org/TR/html52/browsers.html#browsing-context" target="_blank" rel="noopener">https://www.w3.org/TR/html52/browsers.html#browsing-context</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;code&gt;eventloop&lt;/code&gt;是一个经常被提起的话题。且经常以”讲下js中的eventloop”开始。要搞清楚这个问题，要把&lt;code&gt;js&lt;/code&gt;分成两个部分: es规范和js运行时。es规范中阐述了运行时的一些规则，比如执行上下文栈，Promise等
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Promise</title>
    <link href="https://ginobilee.github.io/2019/01/24/Promise/"/>
    <id>https://ginobilee.github.io/2019/01/24/Promise/</id>
    <published>2019-01-24T07:33:41.000Z</published>
    <updated>2019-01-24T13:57:47.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>inversion of control. 不再是将自己的回调传给异步操作；而是等待异步操作的结果然后主动进行自己的回调</li></ol><blockquote><p>Because Promises encapsulate the time-dependent state – waiting on the fulfillment or rejection of the underlying value – from the outside, the Promise itself is time-independent, and thus Promises can be composed (combined) in predictable ways regardless of the timing or outcome underneath.</p></blockquote><blockquote><p>Moreover, once a Promise is resolved, it stays that way forever – it becomes an immutable value at that point – and can then be observed as many times as necessary.</p></blockquote><p>Note: Because a Promise is externally immutable once resolved, it’s now safe to pass that value around to any party and know that it cannot be modified accidentally or maliciously. This is especially true in relation to multiple parties observing the resolution of a Promise. It is not possible for one party to affect another party’s ability to observe Promise resolution. Immutability may sound like an academic topic, but it’s actually one of the most fundamental and important aspects of Promise design, and shouldn’t be casually passed over.</p><p>Promises are an easily repeatable mechanism for encapsulating and composing future values.</p><p>使用promise提供对未来结果的placeholder，于是可以继续组织依赖于此未来操作的逻辑。</p><h3 id="how-to-identify-a-Promise"><a href="#how-to-identify-a-Promise" class="headerlink" title="how to identify a Promise?"></a>how to identify a Promise?</h3><p>duck typing:  “If it looks like a duck, and quacks like a duck, it must be a duck”<br>the duck typing check for a thenable would roughly be:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (</span><br><span class="line">p !== <span class="literal">null</span> &amp;&amp;</span><br><span class="line">(</span><br><span class="line"><span class="keyword">typeof</span> p === <span class="string">"object"</span> ||</span><br><span class="line"><span class="keyword">typeof</span> p === <span class="string">"function"</span></span><br><span class="line">) &amp;&amp;</span><br><span class="line"><span class="keyword">typeof</span> p.then === <span class="string">"function"</span></span><br><span class="line">) &#123;</span><br><span class="line"><span class="comment">// assume it's a thenable!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// not a thenable</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> but if you happen to meet some object having ‘then’ function, where at the same time behaves not like Promise, it may be a disaster…</p><p>直接用 instanceof 做检测存在如下问题:</p><ol><li>Mainly, you can receive a Promise value from another browser window (iframe, etc.), which would have its own Promise different from the one in the current window/frame, and that check would fail to identify the Promise instance.</li><li>a library or framework may choose to vend its own Promises and not use the native ES6 Promise implementation to do so. </li></ol><p>但对这些仍然应该视作 Promise ，所以才会有 duck typing。然而，如果有一个对象碰巧有 then 函数，却不符合 Promise 规范，那就麻烦了。</p><blockquote><p>The characteristics of Promises are intentionally designed to provide useful, repeatable answers to all these concerns.</p></blockquote><h3 id="Promise-Scheduling-Quirks"><a href="#Promise-Scheduling-Quirks" class="headerlink" title="Promise Scheduling Quirks"></a>Promise Scheduling Quirks</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">resolve( <span class="string">"B"</span> );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">resolve( p3 );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>( <span class="function"><span class="keyword">function</span>(<span class="params">resolve,reject</span>)</span>&#123;</span><br><span class="line">resolve( <span class="string">"A"</span> );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">p1.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( v );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line">p2.then( <span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line"><span class="built_in">console</span>.log( v );</span><br><span class="line">&#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">// A B  &lt;-- not  B A  as you might expect</span></span><br></pre></td></tr></table></figure><p>todo: 还可以在 resolve 中传入一个 promise，看看后面怎么解释规范的规定<br>todo: We’ll cover later how to be notified of an error in your callback, because even those don’t get swallowed.</p><blockquote><p>To avoid such nuanced nightmares, you should never rely on anything about the ordering/scheduling of callbacks across Promises. In fact, a good practice is not to code in such a way where the ordering of multiple callbacks matters at all. Avoid that if you can.</p></blockquote><p>在 promise 的 then 回调中抛异常会是什么影响？</p><h3 id="神奇的-Promise-resolve"><a href="#神奇的-Promise-resolve" class="headerlink" title="神奇的 Promise.resolve()"></a>神奇的 Promise.resolve()</h3><blockquote><p>Promise.resolve(..) will accept any thenable, and will unwrap it to its non-thenable value. But you get back from Promise.resolve(..) a real, genuine Promise in its place, one that you can trust. If what you passed in is already a genuine Promise, you just get it right back, so there’s no downside at all to filtering through Promise.resolve(..) to gain trust.</p></blockquote><blockquote><p>Note: Another beneficial side effect of wrapping Promise.resolve(..) around any function’s return value (thenable or not) is that it’s an easy way to normalize that function call into a well-behaving async task. If foo(42) returns an immediate value sometimes, or a Promise other times, Promise.resolve( foo(42) ) makes sure it’s always a Promise result. And avoiding Zalgo makes for much better code.</p></blockquote><h3 id="Chain-flow"><a href="#Chain-flow" class="headerlink" title="Chain flow"></a>Chain flow</h3><blockquote><p>If a proper valid function is not passed as the fulfillment handler parameter to then(..), there’s also a default handler substituted:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve( <span class="number">42</span> );</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line"><span class="comment">// assumed fulfillment handler, if omitted or</span></span><br><span class="line"><span class="comment">// any other non-function value passed</span></span><br><span class="line"><span class="comment">// function(v) &#123;</span></span><br><span class="line"><span class="comment">//     return v;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"><span class="literal">null</span>,</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">rejected</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line"><span class="comment">// never gets here</span></span><br><span class="line">&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p></blockquote><p>这就是为什么如果在 then 中只传入一个非函数的话，会 resolve 为一个具备之前 promise 的值的 promise<br>事实上，上面那段的 <code>then</code> 代码等同于 <code>p.catch(rejected)</code>。这样理解就很清晰了。</p><h3 id="Promise-构造器中的第一个参数为何命名-resolve-而不是-fullfill"><a href="#Promise-构造器中的第一个参数为何命名-resolve-而不是-fullfill" class="headerlink" title="Promise 构造器中的第一个参数为何命名 resolve 而不是 fullfill ?"></a>Promise 构造器中的第一个参数为何命名 resolve 而不是 fullfill ?</h3><p>它实际上执行的是 resolve 操作。如果在构造器中 <code>resolve(Promise.reject(1))</code> 那么这个 promise 的 state 还是 <code>rejected</code>。所以命名为 resolve 更准确。<br>同时注意，reject参数就不会执行 unwrap，如果给传穿一个 promise，会直接当作 reject 的值跑出去，当前 promise 还是 rejected.  </p><blockquote><p>Warning: The previously mentioned reject(..) does not do the unwrapping that resolve(..) does. If you pass a Promise/thenable value to reject(..), that untouched value will be set as the rejection reason. A subsequent rejection handler would receive the actual Promise/thenable you passed to reject(..), not its underlying immediate value.</p></blockquote><h3 id="error-handling"><a href="#error-handling" class="headerlink" title="error handling"></a>error handling</h3><blockquote><p>try..catch would certainly be nice to have, but it doesn’t work across async operations. That is, unless there’s some additional environmental support, which we’ll come back to with generators in Chapter 4.</p></blockquote><blockquote><p>Warning: If you use the Promise API in an invalid way and an error occurs that prevents proper Promise construction, the result will be an immediately thrown exception, not a rejected Promise. Some examples of incorrect usage that fail Promise construction: new Promise(null), Promise.all(), Promise.race(42), and so on. You can’t get a rejected Promise if you don’t use the Promise API validly enough to actually construct a Promise in the first place!</p></blockquote><p>todo: promise.defer ???</p><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h3><blockquote><p>Note: Technically, the array of values passed into Promise.all([ .. ]) can include Promises, thenables, or even immediate values. Each value in the list is essentially passed through Promise.resolve(..) to make sure it’s a genuine Promise to be waited on, so an immediate value will just be normalized into a Promise for that value. If the array is empty, the main Promise is immediately fulfilled.</p></blockquote><blockquote><p>Remember to always attach a rejection/error handler to every promise, even and especially the one that comes back from Promise.all([ .. ]).</p></blockquote><blockquote><p>It doesn’t make much practical sense to have a race with immediate values, because the first one listed will obviously win – like a foot race where one runner starts at the finish line!</p></blockquote><h3 id="Promise-的构造器参数-resolve-中可以接受一个-promise-Promise-resolve同样"><a href="#Promise-的构造器参数-resolve-中可以接受一个-promise-Promise-resolve同样" class="headerlink" title="Promise 的构造器参数 resolve 中可以接受一个 promise (Promise.resolve同样)"></a>Promise 的构造器参数 resolve 中可以接受一个 promise (Promise.resolve同样)</h3><p>es规范中:</p><blockquote><br>A promise is said to be settled if it is not pending, i.e. if it is either fulfilled or rejected.<br><br>A promise is resolved if it is settled or if it has been “locked in” to match the state of another promise. Attempting to resolve or reject a resolved promise has no effect. A promise is unresolved if it is not resolved. An unresolved promise is always in the pending state. A resolved promise may be pending, fulfilled or rejected.<br></blockquote> <blockquote><p>The resolve function that is passed to an executor function accepts a single argument. The executor code may eventually call the resolve function to indicate that it wishes to resolve the associated Promise object. The argument passed to the resolve function represents the eventual value of the deferred action and can be either the actual fulfillment value or another Promise object which will provide the value if it is fulfilled.</p></blockquote><p>看到这里的 resolved/settled/locked in 确实没有看明白。在 ‘You-Dont-Know-JS’ 里看到可以resolve一个promise，才算明白了规范中所说的一个 resolved 的 <code>promise</code>，也可能是 pending，但却不会被再次resolve。</p><p>ref:<br><a href="https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md" target="_blank" rel="noopener">https://github.com/getify/You-Dont-Know-JS/blob/master/async%20%26%20performance/ch3.md</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;inversion of control. 不再是将自己的回调传给异步操作；而是等待异步操作的结果然后主动进行自己的回调&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;Because Promises encapsulate the time-depen
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从规范看赋值表达式的解析</title>
    <link href="https://ginobilee.github.io/2019/01/24/%E4%BB%8E%E8%A7%84%E8%8C%83%E7%9C%8B%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>https://ginobilee.github.io/2019/01/24/从规范看赋值表达式的解析/</id>
    <published>2019-01-24T01:23:04.000Z</published>
    <updated>2019-01-24T07:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>从一道常见的面试题开始:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = a.y = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.x);</span><br><span class="line"><span class="built_in">console</span>.log(b.y);</span><br></pre></td></tr></table></figure></p><p>显然，关键点在于最后一个语句的执行。这个语句的执行主要涉及了 <em>属性获取表达式</em> 和 <em>赋值表达式</em>，先去规范里看对于这两种语法及其执行的规定。</p><h2 id="1-赋值表达式"><a href="#1-赋值表达式" class="headerlink" title="1. 赋值表达式"></a>1. 赋值表达式</h2><p>规范中规定了三种形式的赋值表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AssignmentExpression : </span><br><span class="line">ConditionalExpression</span><br><span class="line">LeftHandSideExpression = AssignmentExpression </span><br><span class="line">LeftHandSideExpression AssignmentOperator AssignmentExpression</span><br></pre></td></tr></table></figure></p><p><code>a.x = a = a.y = {n: 2};</code> 是其中的第二种形式 (第三种形式中的<strong>AssignmentOperator</strong>在规范中是复合赋值符号，即 <code>+=</code> 等等)。 有的同学说，js中<code>=</code>是从右向左执行的。对于语句的执行，规范中写道: </p><blockquote><p>The source text of an ECMAScript program is first converted into a sequence of input elements, which are tokens, line terminators, comments, or white space. The source text is scanned from left to right, repeatedly taking the longest possible sequence of characters as the next input element.</p></blockquote><p>也就是说，源代码被转换为一系列的输入单元(输入单元的类型包括token，行结束符，注释和空白符); 然后从左到右进行解析，重复以最长子序列作为下一个输入单元。除此之外，规范规定了每种类型语句的执行流程，却并没有地方提到 <code>=</code> 要从右向左执行。造成这种广泛的误解的，可能是类似 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">MDN</a> 在语句优先级的地方提到了 <code>=</code> 的<em>Associativity</em>是从右到左，但其实这个<em>Associativity</em>并不是执行流程。</p><p>规范中规定了表达式  <strong>AssignmentExpression : LeftHandSideExpression = AssignmentExpression</strong> 的执行流程(11.13.1节中)，我们把这个流程命名为 parseAssignment, 后面会以 parseAssignment(n)来指代执行这里的第n步:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The production AssignmentExpression : LeftHandSideExpression = AssignmentExpression is evaluated as follows:</span><br><span class="line">1. Let lref be the result of evaluating LeftHandSideExpression.</span><br><span class="line">2. Let rref be the result of evaluating AssignmentExpression.</span><br><span class="line">3. Let rval be GetValue(rref).</span><br><span class="line">4. Throw a SyntaxError exception if the following conditions are all true:</span><br><span class="line">  Type(lref) is Reference is true</span><br><span class="line">  IsStrictReference(lref) is true</span><br><span class="line">  Type(GetBase(lref)) is Environment Record</span><br><span class="line">  GetReferencedName(lref) is either &quot;eval&quot; or &quot;arguments&quot;</span><br><span class="line">5. Call PutValue(lref, rval).</span><br><span class="line">6. Return rval.</span><br></pre></td></tr></table></figure></p><p>显然，第一步是 <code>evaluating LeftHandSideExpression</code> ，将结果赋给变量 <code>lref</code> 。然后是 <code>evaluating AssignmentExpression</code>， 将结果付给 <code>rref</code>。那么在表达式 <code>a.x = a = a.y = {n: 2}</code> 中 哪一部分是 <code>LeftHandSideExpression</code>, 哪一部分是 <code>rref</code> 有没有疑问呢？会不会<br><code>a.x = a</code> 或者 <code>a.x = a = a.y</code> 是 <code>LeftHandSideExpression</code> 呢？</p><p>再来看 <code>LeftHandSideExpression</code> 的语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LeftHandSideExpression : </span><br><span class="line">NewExpression </span><br><span class="line">CallExpression</span><br></pre></td></tr></table></figure></p><p>只有这两种形式，它们具体的语法定义我们就不翻了，不然可能会翻出10多层(事实上，规范中正是通过这种嵌套的表达式语法定义，规定了其优先级)。总之没有赋值表达式，并没有涉及到 <code>=</code> 语法。</p><p>且规范中规定了<em>语句解析顺序</em>是从左到右(Chapter 7)，所以 <code>a.x = a = a.y = {n: 2};</code> 中的 LeftHandSideExpression 就是 <code>a.x</code> 。</p><p>再仔细思考 <code>AssignmentExpression : LeftHandSideExpression = AssignmentExpression</code>， 把最后的 <code>AssignmentExpression</code>置换为左边的 <code>AssignmentExpression</code>，就得到了我们使用的这个表达式 : <code>AssignmentExpression : LeftHandSideExpression = (LeftHandSideExpression = AssignmentExpression)</code>。从这里我们也能看出，对于<code>a.x = a = a.y = {n: 2};</code>的执行来说，是<strong>先把 <code>a.x</code> 当作 <code>LeftHandSideExpression</code>，把<code>a = a.y = {n: 2}</code>当作 <code>AssignmentExpression</code>；执行到 <code>evaluating AssignmentExpression</code>时，再把 <code>a</code> 当作 <code>LeftHandSideExpression</code>， <code>a.y = {n: 2}</code>作为 <code>AssignmentExpression</code>。直到最后以 <code>a.y</code> 作为 <code>LeftHandSideExpression</code>， 以 <code>{n: 2}</code>作为<code>AssignmentExpression</code>(<code>AssignmentExpression</code>的第一种形式<code>ConditionalExpression</code>是允许为 对象字面量 的)。</strong></p><p>按照这样的执行步骤，第一步就是把 执行 <code>a.x</code> 的结果赋给 <code>lref</code>，<code>a.x</code>是一个 属性读取表达式，我们再来看它的执行流程。</p><pre><code>【Note】规范中并没有对优先级进行规定，只是通过设置语句的解析规则，形成了事实上的优先级。读者可以试试这段代码的结果:    var a = &quot;a&quot;    console.log(a) // &apos;a&apos;    true ? a : a = &apos;c&apos;    console.log(a) // &apos;a&apos;    false ? a : a = &quot;c&quot;    console.log(a) // &apos;c&apos;若按照优先级规定，条件表达式的优先级高于赋值表达式；那么语句应该按照 先执行条件表达式，后执行赋值表达式的顺序执行，第二个输出就应该是&apos;c&apos;了。但事实上是&apos;a&apos;。这是因为按照规范的表达式解析规则，=的左边总是被解析为 LeftHandSideExpression，而条件表达式并不在它的语法形式之中。所以按照最大可解析长度的原则，上式被解析为了true ? a : (a = &apos;c&apos;)，所以只有在最后 a 才会被改写为&apos;c&apos;。</code></pre><h2 id="2-属性获取表达式"><a href="#2-属性获取表达式" class="headerlink" title="2. 属性获取表达式"></a>2. 属性获取表达式</h2><p>规范中在 <code>LeftHandSideExpression</code> 相关 <code>Property Accessors</code>(11.2.1节) 中规定了其执行流程，我们把这个流程命名为 parseMember, 后面会以 parseMember(n)来指代执行这里的第n步:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:</span><br><span class="line">1. Let baseReference be the result of evaluating MemberExpression.</span><br><span class="line">2. Let baseValue be GetValue(baseReference).</span><br><span class="line">3. Let propertyNameReference be the result of evaluating Expression.</span><br><span class="line">4. Let propertyNameValue be GetValue(propertyNameReference).</span><br><span class="line">5. Call CheckObjectCoercible(baseValue).</span><br><span class="line">6. Let propertyNameString be ToString(propertyNameValue).</span><br><span class="line">7. If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let</span><br><span class="line">strict be false.</span><br><span class="line">8. Return a value of type Reference whose base value is baseValue and whose referenced name is</span><br><span class="line">propertyNameString, and whose strict mode flag is strict.</span><br></pre></td></tr></table></figure></p><p>我们看到这个流程大概是，从 <code>MemberExpression</code> (即这里的 <code>a</code>) 得到<code>baseValue</code>, 从 <code>Expression</code> (即这里的字符串 <code>x</code> )得到 <code>propertyNameString</code>，然后返回以它们组成的 <code>Reference</code>。<br>我们先去了解下 <code>Reference</code> 。</p><h2 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3. Reference"></a>3. Reference</h2><p>规范的第8章 <code>Types</code> 中, 将类型分为两大类: 一是<em>语言类型</em>，也就是提供给开发者的<code>Undefined, Null, Boolean, String, Number, and Object</code>；另一类是 <em>规范类型</em>，它们不会提供给开发者，也不一定对应到一个es实现中的数据结构，只是用来描述规范中的算法和刚才提到的<em>语言类型</em>，可以理解为是用来描述算法和数据结构的抽象。<code>Reference</code> 就是<em>规范类型</em>的一种。</p><p>规范的8.7节中这样写到: </p><blockquote><p>A Reference is a resolved name binding. A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.</p></blockquote><p>意即，<code>Reference</code> 是一个 <strong>已解析的命名绑定</strong>。所谓<strong>命名绑定</strong>，就是说它用来用一个<strong>命名</strong>找到对应的某个内部数值/数据；所谓<strong>已解析</strong>，就是说这个 命名 到 数据 的绑定关系是确定的。好比我们在面对函数中的某个变量，想要知道它的确切值是多少，就是想确定它的命名绑定。<br>简而言之，<code>Reference</code> 就是一个表示<em>引用类型</em>或者<em>环境对象</em>的抽象。一个 <code>Reference</code> 由三个部分组成: <code>base</code>  、 <code>reference name</code> 、 <code>strict flag</code>。</p><p><code>base</code>可以看作是就是引用的实体或作宿主，好比 <code>a.x</code> 就是一个引用，它的 <code>base value</code>就是 <code>a</code>；<code>reference name</code> 则是字符串 <code>x</code>。而在如下函数<code>func</code>中:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>a</code> 也是一个引用，它的 <code>base</code> 是 <code>func</code> 函数对应的执行环境的环境记录(<code>Enviroment Record</code>); <code>reference name</code>则是字符串 <code>&#39;a&#39;</code>。</p><p>前述表达式的执行流程中还用到了 <code>Reference</code> 的 <code>GetValue</code> 方法。我们看它的执行过程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GetValue (V)</span><br><span class="line">1. If Type(V) is not Reference, return V.</span><br><span class="line">2. Let base be the result of calling GetBase(V). // 获取 Reference 的 base component</span><br><span class="line">3. If IsUnresolvableReference(V), throw a ReferenceError exception.</span><br><span class="line">4. If IsPropertyReference(V), then</span><br><span class="line">a. If HasPrimitiveBase(V) is false, then let get be the [[Get]] internal method of base, otherwise let get be the special [[Get]] internal method defined below.</span><br><span class="line">b. Return the result of calling the get internal method using base as its this value, and passing GetReferencedName(V) for the argument.</span><br><span class="line">5. Else, base must be an environment record.</span><br><span class="line">a. Return the result of calling the GetBindingValue (see 10.2.1) concrete method of base passing</span><br><span class="line">GetReferencedName(V) and IsStrictReference(V) as arguments.</span><br></pre></td></tr></table></figure></p><p>即，如果参数 <code>V</code> 不是一个 <code>Reference</code> 类型，那么直接返回；否则在 <code>base</code>上取出对应 <code>reference name</code>的值并返回。</p><h2 id="4-题目分析"><a href="#4-题目分析" class="headerlink" title="4. 题目分析"></a>4. 题目分析</h2><p>有了这些基础，我们可以来分析面试题中的表达式了。步骤如下: </p><ol><li><p>执行parseAssignment(1), 即执行 <code>a.x</code> 表达式，将得到的 <code>Reference</code> 类型值赋给 <code>lref</code>。<code>a.x</code> 是一个 <code>Property Accessor</code>，我们来按照规范解析它的执行:</p><pre><code>1.1 parseMember(1). MemberExpression 是 a。这是表达式 PrimaryExpression 的 Identifier 类型，它会返回一个 Reference 类型的值: base 是全局环境变量(global enviroment record)，reference name是&apos;a&apos;，strict flag是false。 1.2 parseMember(2). 对全局环境变量调用 GetBindingValue(&apos;a&apos;)方法，在变量对象中找到对应的值，即 a 所引用的 对象字面量 {n: 1}。1.3 parseMember(3). Let propertyNameReference  = &apos;x&apos;1.4 parseMember(4). Let propertyNameValue = &apos;x&apos;1.5 parseMember(5). 检查是否可以1.2中的返回值是否可以转为 Object, {n: 1}本就是对象类型，返回true1.6 parseMember(6). 获取property name string，即&apos;x&apos;1.7 parseMember(7). 设置 strict flag 为false1.8 parseMember(8). 返回一个 Reference 类型的值，base 是 {n: 1}, reference name是&apos;x&apos;， strict flag 是 false。</code></pre><p> 这里第一步执行完得到的 lref 就是1.8中返回的值。</p></li><li><p>parseAssignment(2). 执行 a = a.y = {n: 2}，将返回值赋给 rref。它的执行如下: </p><pre><code>2.1 执行 a。它返回一个 Reference 类型的值，base 是 全局环境变量，refrence name是&apos;a&apos;, strict flag是false。我们姑且称这一步的lref为 lref2.1。2.2 执行 a.y = {n: 2}。它也是一个赋值表达式，执行如下:    2.2.1 执行 a.y 。这里又涉及到了对 a 的解析，前面的操作并没有改变 a 的引用，所以到现在为止，a 仍然会被解析为全局环境变量上的一个命名绑定。所以对 a.y 的解析所返回的 Reference 中，base 组件是就是lref中的base。 我们姑且称这一步的lref为 lref2.2.1，它的组成: base 是 {n: 1}，refrence name是&apos;y&apos;, strict flag是false。(注意 lref2.2.1 的 base 与 lref 的 base， 是同一个对象。因为 a 都会解析为 全局环境变量 上对应属性&apos;a&apos;的对象。)    2.2.2 parseAssignment(2). 这里右边是一个 对象初始化表达式，返回一个对象类型的值 {n: 2}。    2.2.3 parseAssignment(3). 对上一步中的返回值执行 GetValue(rref)，结果仍然是 {n: 2}, 赋给 rval2.2.3。    2.2.4 parseAssignment(4). 判断是否抛异常，这里不会。    2.2.5 parseAssignment(5). 调用 PutValue(lref2.2.1, rval2.2.3)，结果是lref2.2.1 的base增加了一个属性，此时变为了 {n: 1, y: {n: 2}} // 这里的 base 与 lref 中的 base 仍然是同一个对象    2.2.6 parseAssignment(6). 返回 rval2.2.3。所以这一步返回 rval2.2.3。2.3 parseAssignment(3). 对2.2返回的值进行 GetValue(rref), 仍然是 rval2.2.32.4 parseAssignment(4). 判断是否要抛异常，这里不会。2.5 parseAssignment(5). 调用 PutValue(lref2.1, rval2.2.3)，lref2.1 的base是 全局环境变量，这里修改了其中变量 a 的引用，指向新的对象 rval2.2.32.6 parseAssignment(6). 返回 rval2.2.3。</code></pre><p> 这一步的返回仍然是对象 rval2.2.3。</p></li><li>parseAssignment(3). 将 rval 设为上一步的返回即 rval2.2.3。</li><li>parseAssignment(4). 判断是否要抛异常，这里不会。</li><li>parseAssignment(5). 调用 PutValue(lref, rval)，lref 的base 增加了一个属性，此时变为了 {n: 1, y: {n: 2}, x: {n: 2}}</li><li>Return rval.</li></ol><p>所以执行完后，变量 a 所引用的对象是 {n: 2}。 而它之前指向的对象，也即这时变量<code>b</code>指向的对象(<code>b</code> 的指向未改变过)，变为了 <code>{n: 1, y: {n: 2}, x: {n: 2}}</code>。可以用 JSON.stringify 验证下b。而且这时候 <code>b.x</code> 、<code>b.y</code> 和 a 指向同一个对象。 </p><p>其实这里的关键点就是，赋值表达式要先对左边的表达进行引用确定，再进行赋值。</p><p>PS: 文中对于符号优先级的阐述，完全出于自己对规范的理解，欢迎指正</p><p>PPS: 经社区同学指出，贴出文章所参照的规范地址<a href="http://www.ecma-international.org/ecma-262/5.1/index.html" target="_blank" rel="noopener">EcmaScript 5.1 Edition</a>。文章参照的是旧版本，es6之后对于这个问题的分析是一致的，差异主要是:</p><ul><li>表达式增加了更多语法。比如es6中赋值表达式增加了对箭头函数和Yeild语法的支持。</li><li>对应的章节不同。比如es6中表达式放到了第12章，对Reference的阐述放在了6.2.3(The Reference Specification Type )，关于输入源码解析的机制放在了第11章(ECMAScript Language: Lexical Grammar)中。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从一道常见的面试题开始:&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
