<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mg20</title>
  
  <subtitle>知行合一</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://ginobilee.github.io/"/>
  <updated>2019-03-16T23:26:32.000Z</updated>
  <id>https://ginobilee.github.io/</id>
  
  <author>
    <name>mg20</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://ginobilee.github.io/2019/03/17/%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0-leetcode/"/>
    <id>https://ginobilee.github.io/2019/03/17/寻找两个有序数组的中位数-leetcode/</id>
    <published>2019-03-16T22:45:57.000Z</published>
    <updated>2019-03-16T23:26:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>这道题有三个关键点:</p><ol><li>意识到寻找中间点，就是将有序数组拆分为等长的两段，拆分点就是中间点。所以对于两个有序数组，寻找他们合起来的中间点就是分别将两个数组拆分成两段，左边段加起来的长度等于右边段的长度，这样能保证是中间位置；其次保证左边段的末位断点小于右边段的起始端点，则保证了数组合并的拆分点是有序数组的中间点。</li><li>要将分支条件梳理清楚。如满足题意的中间点的条件实际是 <code>(i=0 || j=n || A[i-1]&lt;=B[j])&amp;&amp;(j=0 || i=m || B[j-1]&lt;=A[j])</code> // m&lt;=n。我可以想到要保证端点值大小约束的条件，但对于边界条件如 i=0,i=m… 如何融入进去没有思考清楚。没有思考清楚的原因是也没有去真正细致地把这些条件写出来，而是一想到有这么多边界条件就嫌麻烦，想找捷径；而这里却是真正把所有问题列出来，写写画画，才能把问题看得更清楚的必须路径。即便有麻烦的边界，还是依次把其写出来，去对比思考，才更容易看清楚它的本质。<ol><li>当有了上述条件，就可以找到它的反条件。把 || 和 &amp;&amp; 想成数学上的集合的并与交，即可以推导出它的反条件: <code>!((i=0 || j=n || A[i-1]&lt;=B[j])&amp;&amp;(j=0 || i=m || B[j-1]&lt;=A[j])) &lt;==&gt; (!(i=0 || j=n || A[i-1]&lt;=B[j]) || !(j=0 || i=m || B[j-1]&lt;=A[j])) &lt;==&gt; ((!(i=0) &amp;&amp; !(j=n) &amp;&amp; !(A[i-1]&lt;=B[j])) || (!(j=0) &amp;&amp; !(i=m) &amp;&amp; !(B[j-1]&lt;=A[j]))) &lt;==&gt; ((i&gt;0 &amp;&amp; j&lt;n &amp;&amp; A[i-1]&gt;B[j]) || (j&gt;0 &amp;&amp; i&lt;m &amp;&amp; B[j-1]&gt;A[j]))</code></li><li>注意上述推导中最后一步，取 <code>i=0</code>的非时，因为i不会小于0，所以直接为<code>i&gt;0</code>。</li><li>至此，就可以将整个算法的分支写为: <ol><li><code>if(i&gt;0 &amp;&amp; j&lt;n &amp;&amp; A[i-1]&gt;B[j])</code></li><li><code>else if(j&gt;0 &amp;&amp; i&lt;m &amp;&amp; B[j-1]&gt;A[j])</code></li><li><code>else{// 找到了匹配的i,j，但i,j可能为边界值。没有关系，只要在计算中位值时注意就可以了}</code></li><li>至此，算法的逻辑已经很清晰了。</li></ol></li></ol></li><li>最后一点是，在<code>m&lt;=n</code>的条件中，<code>i&gt;0</code>与<code>j&lt;n</code>是等价的。如此前述2.3.1和2.3.2中的条件都是可以简写的。具体推导就不写了。关键在于充分利用前提条件<code>m&lt;=n</code>，而自己就忽略了这个条件。</li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function findMedian2(nums1, nums2) &#123;</span><br><span class="line">  let shorter = nums1, longer = nums2, m = nums1.length, n = nums2.length</span><br><span class="line">  if (m &gt; n) &#123;</span><br><span class="line">    shorter = nums2</span><br><span class="line">    longer = nums1</span><br><span class="line">    temp = n</span><br><span class="line">    n = m</span><br><span class="line">    m = temp</span><br><span class="line">  &#125;</span><br><span class="line">  let iMin = 0, iMax = m, halfLength = Math.floor((m + n + 1) / 2)</span><br><span class="line">  while (iMin &lt;= iMax) &#123;</span><br><span class="line">    const i = Math.floor((iMin + iMax) / 2)</span><br><span class="line">    const j = halfLength - i</span><br><span class="line">    if (i &lt; iMax &amp;&amp; longer[j - 1] &gt; shorter[i]) &#123;</span><br><span class="line">      // i is small</span><br><span class="line">      iMin = i + 1</span><br><span class="line">    &#125; else if (i &gt; iMin &amp;&amp; shorter[i - 1] &gt; longer[j]) &#123;</span><br><span class="line">      // i is big</span><br><span class="line">      iMax = i - 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      let maxLeft = 0</span><br><span class="line">      if (i === 0) &#123;</span><br><span class="line">        maxLeft = longer[j - 1]</span><br><span class="line">      &#125; else if (j === 0) &#123;</span><br><span class="line">        maxLeft = shorter[i - 1]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        maxLeft = Math.max(shorter[i - 1], longer[j - 1])</span><br><span class="line">      &#125;</span><br><span class="line">      if ((m + n) % 2 === 1) return maxLeft</span><br><span class="line"></span><br><span class="line">      let minRight = 0</span><br><span class="line">      if (i === m) &#123;</span><br><span class="line">        minRight = longer[j]</span><br><span class="line">      &#125; else if (j === n) &#123;</span><br><span class="line">        minRight = shorter[i]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        minRight = Math.min(shorter[i], longer[j])</span><br><span class="line">      &#125;</span><br><span class="line">      return (maxLeft + minRight) / 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="自己的初始思路"><a href="#自己的初始思路" class="headerlink" title="自己的初始思路"></a>自己的初始思路</h3><p>自己也想出了一个思路，只是代码写起来非常复杂和容易出错，且算法复杂度应该是 <code>O(log(m)log(n))</code> 的。不过自己也花了很大的心思写出来了，还是值得记录一下的。<br>思路就是，在两个数组出现交叉时，寻找开始端点较大者在对方数组的插入位置: </p><ol><li>若此位置大于所要的中间位数(它是固定的)，则中间点必在对方数组中，根据所要中位数下标即可找到</li><li>若此位置等于所要的中间位数，则他就是要找的中间点，再通过比较两个数组的下一个节点大小，即可找到</li><li>若此位置小于所要的中间位数，则取对方数组的(所找到的插入位置的下一个)元素为待查找元素，反过来在自己的数组中，从刚才的查找元素之后开始查找，再取比较其相对位置与中位数所需的相对位置的偏差，即进入下一个循环。</li></ol><p>这样如果在查找时用二分查找，那么效率是 <code>O(log(searchlength))</code> 的。而进行查找的个数，因为是对方分片查找导致的，也可以认为是 <code>O(log(length))</code>。所以可以视整体复杂度为 <code>O(log(m)log(n))</code>。<br>这道题自己可以把自己的思路坚持写出来，并通过测试集，击败将近 50% 的同语言算法，还是不错的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">var findMedianSortedArrays = function(nums1, nums2) &#123;</span><br><span class="line">  function getMedian(arr, idxOfMid) &#123;</span><br><span class="line">    const l = arr.length</span><br><span class="line">    if (l % 2 === 1) &#123;</span><br><span class="line">      return arr[idxOfMid]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return (arr[idxOfMid] + arr[idxOfMid - 1]) / 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // if one is empty</span><br><span class="line">  const arr1 = nums1,</span><br><span class="line">    arr2 = nums2</span><br><span class="line">  if (nums1.length === 0 || nums2.length === 0) &#123;</span><br><span class="line">    let noneEmptyArr = arr1.length === 0 ? arr2 : arr1</span><br><span class="line">    const l = noneEmptyArr.length</span><br><span class="line">    const idx1 = Math.floor(l / 2)</span><br><span class="line">    return getMedian(noneEmptyArr, idx1)</span><br><span class="line">  &#125;</span><br><span class="line">  // if one&apos;s end is little than another&apos;s start</span><br><span class="line">  const l = arr1.length + arr2.length</span><br><span class="line">  const arr1LittleThanArr2 = !(arr1[arr1.length - 1] &gt; arr2[0])</span><br><span class="line">  const arr2LittleThanArr1 = !(arr2[arr2.length - 1] &gt; arr1[0])</span><br><span class="line">  if (arr1LittleThanArr2 || arr2LittleThanArr1) &#123;</span><br><span class="line">    const littleOne = arr1LittleThanArr2 ? arr1 : arr2,</span><br><span class="line">      biggerOne = arr1LittleThanArr2 ? arr2 : arr1</span><br><span class="line">    const idx1 = Math.floor(l / 2)</span><br><span class="line">    if (l % 2 === 1) &#123;</span><br><span class="line">      if (idx1 &lt; littleOne.length) &#123;</span><br><span class="line">        return littleOne[idx1]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return biggerOne[idx1 - littleOne.length]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const m1 = idx1 &lt; littleOne.length ? littleOne[idx1] : biggerOne[idx1 - littleOne.length]</span><br><span class="line">      const idx2 = idx1 - 1</span><br><span class="line">      const m2 = idx2 &lt; littleOne.length ? littleOne[idx2] : biggerOne[idx2 - littleOne.length]</span><br><span class="line">      return (m1 + m2) / 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // has inter items</span><br><span class="line">  // prepare for first lookup</span><br><span class="line">  let target = arr1[0] &lt; arr2[0] ? arr1 : arr2,</span><br><span class="line">    another = arr1[0] &lt; arr2[0] ? arr2 : arr1</span><br><span class="line">  // idxLE: indexOfLookupElement, ssIdx: searchStartIndex, idxTBS: idxToBeSearched</span><br><span class="line">  let idxLE = 0,</span><br><span class="line">    e = another[idxLE],</span><br><span class="line">    ssIdx = 0,</span><br><span class="line">    idxTBS = Math.floor(l / 2)</span><br><span class="line">  if (l % 2 === 0) &#123;</span><br><span class="line">    idxTBS -= 1</span><br><span class="line">  &#125;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    // iPos: interplationPosition, the biggest position &apos;e&apos; can be interplated in target</span><br><span class="line">    let iPos = findLastPos(target, ssIdx, target.length - 1, e)</span><br><span class="line">    // relL: relative length</span><br><span class="line">    const relL = iPos - ssIdx</span><br><span class="line">    if (relL &gt; idxTBS) &#123;</span><br><span class="line">      const m1 = target[ssIdx + idxTBS]</span><br><span class="line">      if (l % 2 === 1) &#123;</span><br><span class="line">        return m1</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        const m2 = target.length &gt; ssIdx + idxTBS + 1 ? (target[ssIdx + idxTBS + 1] &gt; e ? e : target[ssIdx + idxTBS + 1]) : e</span><br><span class="line">        return (m1 + m2) / 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (relL === idxTBS) &#123;</span><br><span class="line">      if (l % 2 === 1) &#123;</span><br><span class="line">        return e</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        idx2 = another[idxLE + 1]</span><br><span class="line">        const m2 = target.length &gt; ssIdx + idxTBS ? (target[ssIdx + idxTBS] &gt; idx2 ? idx2 : target[ssIdx + idxTBS]) : idx2</span><br><span class="line">        return (e + m2) / 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // // &apos;another&apos; has no elements need to search any more</span><br><span class="line">      if (idxLE === another.length - 1) &#123;</span><br><span class="line">        const idx1 = idxTBS + ssIdx - 1</span><br><span class="line">        if (l % 2 === 1) &#123;</span><br><span class="line">          return target[idx1]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return (target[idx1] + target[idx1 + 1]) / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (iPos === target.length) &#123;</span><br><span class="line">        // &apos;target&apos; has no more elements to search</span><br><span class="line">        const idx1 = idxLE + relL</span><br><span class="line">        if (l % 2 === 1) &#123;</span><br><span class="line">          return another[idx1]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return (another[idx1] + another[idx1 + 1]) / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ssIdx = idxLE + 1</span><br><span class="line">        idxTBS = idxTBS - relL - 1</span><br><span class="line">        idxLE = iPos</span><br><span class="line">        // switch target and another</span><br><span class="line">        const temp = target</span><br><span class="line">        target = another</span><br><span class="line">        another = temp</span><br><span class="line">        e = another[idxLE]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&quot;error&quot;)</span><br><span class="line">  function findLastPos(arr, start, end, item) &#123;</span><br><span class="line">    const mid = Math.floor((end + start) / 2)</span><br><span class="line">    if (start &gt;= arr.length) &#123;</span><br><span class="line">      return arr.length - 1</span><br><span class="line">    &#125;</span><br><span class="line">    if (start &gt; end) &#123;</span><br><span class="line">      return start</span><br><span class="line">    &#125;</span><br><span class="line">    if (arr[mid] &lt; item) &#123;</span><br><span class="line">      start = mid + 1</span><br><span class="line">      if (start &gt;= arr.length) &#123;</span><br><span class="line">        return start</span><br><span class="line">      &#125;</span><br><span class="line">      return findLastPos(arr, start, end, item)</span><br><span class="line">    &#125; else if (arr[mid] === item) &#123;</span><br><span class="line">      let cur = mid</span><br><span class="line">      while (arr[++cur] === item) &#123;&#125;</span><br><span class="line">      return cur</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      end = mid - 1</span><br><span class="line">      if (end &lt; 0) &#123;</span><br><span class="line">        return 0</span><br><span class="line">      &#125;</span><br><span class="line">      return findLastPos(arr, start, end, item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这道题有三个关键点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;意识到寻找中间点，就是将有序数组拆分为等长的两段，拆分点就是中间点。所以对于两个有序数组，寻找他们合起来的中间点就是分别将两个数组拆分成两段，左边段加起来的长度等于右边段的长度，这样能保证是中间位置；其次保证左边段的末位断点小
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>面试之js、css的放置位置</title>
    <link href="https://ginobilee.github.io/2019/02/13/%E9%9D%A2%E8%AF%95%E4%B9%8Bjs%E3%80%81css%E7%9A%84%E6%94%BE%E7%BD%AE%E4%BD%8D%E7%BD%AE/"/>
    <id>https://ginobilee.github.io/2019/02/13/面试之js、css的放置位置/</id>
    <published>2019-02-13T14:06:03.000Z</published>
    <updated>2019-02-17T08:32:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>这些问题自己之前也思考过，也在通过阅读规范、chrome文档以及浏览器测试总结。刚好面试中问到了，就此总结一下。</p><h3 id="doctype-声明有什么作用，如果不写会怎么样？如果把一个html5-的文档当作其它文档类型解析了会怎么样？"><a href="#doctype-声明有什么作用，如果不写会怎么样？如果把一个html5-的文档当作其它文档类型解析了会怎么样？" class="headerlink" title="doctype 声明有什么作用，如果不写会怎么样？如果把一个html5 的文档当作其它文档类型解析了会怎么样？"></a>doctype 声明有什么作用，如果不写会怎么样？如果把一个html5 的文档当作其它文档类型解析了会怎么样？</h3><p>html5已经不是SGML语言的子集，因此不再需要文档类型定义。实际上，浏览器现在只是通过DOCTYPE 声明来决定使用何种模式(standard mode/quirk mode)来进行文档解析和渲染。</p><blockquote><p>DOCTYPEs are required for legacy reasons. <strong><em>When omitted, browsers tend to use a different rendering mode that is incompatible with some specifications. Including the DOCTYPE in a document ensures that the browser makes a best-effort attempt at following the relevant specifications.</em></strong></p></blockquote><blockquote><p>In HTML5, the only purpose of the DOCTYPE is to activate full standards mode. Older versions of the HTML standard gave additional meaning to the DOCTYPE, but no browser has ever used the DOCTYPE for anything other than switching between quirks mode and standards mode.</p></blockquote><h3 id="js和css的放置位置"><a href="#js和css的放置位置" class="headerlink" title="js和css的放置位置"></a>js和css的放置位置</h3><h4 id="为什么要把-css-放在-head里，而js-放在-body-后？js应该放在-后还是前？"><a href="#为什么要把-css-放在-head里，而js-放在-body-后？js应该放在-后还是前？" class="headerlink" title="为什么要把 css 放在 head里，而js 放在 body 后？js应该放在  后还是前？"></a>为什么要把 css 放在 head里，而js 放在 body 后？js应该放在  后还是前？</h4><ol><li>非异步形式的 script，其 <strong><em>加载和执行</em></strong> 都会阻塞 dom解析。即 dom解析会停在 脚本加载处，直到其被加载和执行，才会继续。但是要注意，<strong><em>阻塞 dom 解析，并不是阻塞渲染。浏览器还是会对已经解析的dom进行 样式计算/渲染等操作</em></strong></li><li>从规范角度出发，标签之后不应该再有任何内容，因此放在之后通不过html规范的验证；但实际上浏览器都会兼容这种处理，将script同样当作在内来处理。他们对于性能也没有可以观察到的影响。如果说是不是因为一些遗留原因放在之后更好，这个就不是很清楚了，不过感觉意义不大。</li><li>浏览器不是等待所有文档解析完成才展示，而是当一部分文档达到了展示的条件，就将其展示。因此从尽快展示部分文档的角度出发(非可交互，而是度过白屏)，应该让js放在标签之后。</li><li>defer:<ol><li>执行顺序与引用顺序一致</li><li><strong><em>加载和执行</em></strong> 都不会阻塞 dom解析</li><li>因此会等到 dom解析完再执行</li><li>会在执行完这类脚本后才触发 Domcontentloaded，因此相当于阻塞该事件。当然也阻塞 load 事件。</li><li>对 module scripts 类型的脚本无效。该类脚本默认具有 defer 的效果。</li><li>defer: indicate to a browser that the script is meant <strong><em>to be executed after the document has been parsed, but before firing DOMContentLoaded</em></strong>.</li></ol></li><li>async:<ol><li><strong><em>加载</em></strong> 时不阻塞 dom的解析，但是加载到了后就会进行执行。因此 <strong><em>执行</em></strong> 可能打断 dom解析(进而延迟Domcontentloaded事件)。但如果脚本加载很慢，使用async 则不会阻塞 Domcontentloaded 事件的触发。但仍然会阻塞 load 事件的触发。</li><li>执行顺序不能保证与引用顺序一致</li></ol></li><li>外部css 文件的加载会阻塞 dom解析 么？会阻塞渲染么？<ol><li>既不会阻塞解析，也不会阻塞渲染(chrome观察得出)</li><li>但延迟加载的css会导致样式重新计算，从而导致 无样式闪烁 问题</li></ol></li></ol><blockquote><p>The async and defer attributes are boolean attributes that indicate how the script should be evaluated. Classic scripts may specify defer or async, but must not specify either unless the src attribute is present. Module scripts may specify the async attribute, but must not specify the defer attribute.</p></blockquote><blockquote><p>For classic scripts, if the async attribute is present, then the classic script will be fetched in parallel to parsing and evaluated as soon as it is available (potentially before parsing completes). If the async attribute is not present but the defer attribute is present, then the classic script will be fetched in parallel and evaluated when the page has finished parsing. If neither attribute is present, then the script is fetched and evaluated immediately, blocking parsing until these are both complete.</p></blockquote><blockquote><br>The following sample shows how a script element can be used to include an external module script.<br><script type="module" src="app.mjs"></script><br>This module, and all its dependencies (expressed through JavaScript import statements in the source file), will be fetched. Once the entire resulting module graph has been imported, and the document has finished parsing, the contents of app.mjs will be evaluated.<br>Additionally, if code from another script element in the same Window imports the module from app.mjs (e.g. via import “./app.mjs”;), then the same module script created by the former script element will be imported.<br></blockquote><p>从规范对于module类脚本的阐述来看，其默认带有了classic脚本的defer效果。结合前面的分析，defer也是更合理的异步脚本加载方式。跟放在之前相比，defer完全不阻塞dom的解析；跟async相比，它会延迟执行直到dom解析完，并在Domcontentloaded事件前触发。</p><h4 id="css-如果直接写在html里，它的解析执行会影响dom的解析么？如果两步是分别进行的"><a href="#css-如果直接写在html里，它的解析执行会影响dom的解析么？如果两步是分别进行的" class="headerlink" title="css 如果直接写在html里，它的解析执行会影响dom的解析么？如果两步是分别进行的"></a>css 如果直接写在html里，它的解析执行会影响dom的解析么？如果两步是分别进行的</h4><p>写在 html 里的css，对于dom 来说就是一个 script 节点。它的内容应该是由css 解析器单独解析的，因为其规则与 html 解析规则不一样。那么两者分别解析时，什么时候将两者解析的结果合并处理？是不是 dom 上一个节点处理完了，流式地准备将其进行 render 处理，然后就去查看样式规则(css会最终解析成一条条的规则，还是一棵样式树？cssom 是树结构么？如果是树，那么多个没有关联的样式规则如何整理在一棵树上？应该是一棵树，就算开发者没有写根元素的样式，浏览器会给其添加默认样式，也是以样式表的形式提供的。如此就有了根节点，然后就可以将所有规则构建成一棵树)，然后将节点渲染到页面上。所以，当执行render时，如果样式表为空，那么就会将默认样式渲染在页面上。然后等开发者定义的样式表解析完，再将特定样式附加在对应节点上，然后浏览器重新在页面上重新绘制该元素。<br>以这样的方式来讨论的话，css不会影响或阻塞 首评出现内容的时间，但会影响首屏出现内容的样式。如果css解析地慢，那么首屏出现的内容会发生样式闪烁。所以将css以外链的形式放在head里，也不会影响dom的解析，但会影响首屏内容的渲染结果。再结合浏览器中观察的结果，似乎是先解析dom，然后在样式获取到后进行重新绘制，如果样式获取地早，赶上了第一波绘制前，那么就不会出现样式闪烁？</p><p>看来我的以上认识不正确: </p><blockquote><p>默认情况下，CSS 被视为阻塞渲染的资源，这意味着浏览器将不会渲染任何已处理的内容，直至 CSSOM 构建完毕。<br>应该是: css不阻塞 dom 解析，但是阻塞渲染。按照 google 的文档阐述是这样的，在 domcontentloaded 之前不会执行渲染，因为这个事件标志着 dom 和 cssom 的完成，然后才会开始构建 render tree。  </p></blockquote><p>但实际上好像不是这个样子，在 dcl 之前就已经有内容展示在网页中了。<br>很明显的例子是，我在 head 里加载了一个外链css，通过将网速改为慢速，加载此文件需要 5s+，但在加载到它之前网页上就已经有了文档内容。而从 window.performance.timing.domInteractive 获知，这个时间都是与 window.performance.timing.domContentLoaded… 一致的，都在css文件下载之后才触发。所以浏览器并不是css外部链接并不会阻塞浏览器的渲染，但是会阻塞文档的 loaded，以及出现样式闪烁。  </p><p>ref:<br><a href="https://developers.google.com/web/fundamentals/performance/critical-rendering-path/measure-crp" target="_blank" rel="noopener">评估关键渲染路径</a></p><blockquote><p>CSSOM 为何具有树结构？为页面上的任何对象计算最后一组样式时，浏览器都会先从适用于该节点的最通用规则开始（例如，如果该节点是 body 元素的子项，则应用所有 body 样式），然后通过应用更具体的规则（即规则“向下级联”）以递归方式优化计算的样式。</p></blockquote><p>关于渲染树(render tree):</p><blockquote><br>1. DOM 树与 CSSOM 树合并后形成渲染树。<br>2. 渲染树只包含渲染网页所需的节点。<br>3. 布局计算每个对象的精确位置和大小。<br>4. 最后一步是绘制，使用最终渲染树将像素渲染到屏幕上。<br></blockquote><p>ref:<br><a href="https://developers.google.com/web/tools/lighthouse/audits/first-contentful-paint" target="_blank" rel="noopener">First Contentful Paint</a></p><h4 id="在浏览器中实验的小技巧"><a href="#在浏览器中实验的小技巧" class="headerlink" title="在浏览器中实验的小技巧"></a>在浏览器中实验的小技巧</h4><p>这类问题，要在浏览器中可视化地看到差异和效果，不太好控制。如果不想采用自己控制server端响应的方法，可以采用 chrome 中对于 cpu throttle 和 Network throttle 来模拟各种情况，可以方便快捷地达到各种测验场景。</p><h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><ul><li style="list-style: none"><input type="checkbox" checked> 如果将 defer 的script 放在头部，是否会先于文档中的 img 下载，进而在此类文档很多时影响 img 的下载？  </li></ul><p>实验后发现，defer 的脚本与文档中的 img 引用的图片，优先级都是 low。但因为两者的域名不同，并没有受到下载线程并发个数的影响，图片的下载没有被脚本下载所阻塞。</p><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Quirks_Mode_and_Standards_Mode" target="_blank" rel="noopener">mdn Quirks_Mode_and_Standards_Mode</a></li><li><a href="https://html.spec.whatwg.org/multipage/syntax.html#the-doctype" target="_blank" rel="noopener">html spec the-doctype</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这些问题自己之前也思考过，也在通过阅读规范、chrome文档以及浏览器测试总结。刚好面试中问到了，就此总结一下。&lt;/p&gt;
&lt;h3 id=&quot;doctype-声明有什么作用，如果不写会怎么样？如果把一个html5-的文档当作其它文档类型解析了会怎么样？&quot;&gt;&lt;a href=&quot;#d
      
    
    </summary>
    
    
      <category term="interview html performance 阿里云" scheme="https://ginobilee.github.io/tags/interview-html-performance-%E9%98%BF%E9%87%8C%E4%BA%91/"/>
    
  </entry>
  
  <entry>
    <title>面试之函数的柯里化技巧</title>
    <link href="https://ginobilee.github.io/2019/02/13/%E9%9D%A2%E8%AF%95%E4%B9%8B%E5%87%BD%E6%95%B0%E7%9A%84%E6%9F%AF%E9%87%8C%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <id>https://ginobilee.github.io/2019/02/13/面试之函数的柯里化技巧/</id>
    <published>2019-02-13T13:02:20.000Z</published>
    <updated>2019-02-13T13:58:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>记录下面试的车祸现场</p><h3 id="车祸现场"><a href="#车祸现场" class="headerlink" title="车祸现场"></a>车祸现场</h3><p>面试官出了如下一道题目:<br>封装一个模块，需要这个模块能够支持运算如 <code>curr(7, 8, 9) === curr(7, 8)(9) === curr(7)(8)(9)</code>。即可以用不定的参数调用之，都能实现参数相加。<br>面试官也提到了用柯里化的思路实现。  </p><p>我记得函数的柯里化能够给函数提供动态设定参数的能力，比如原本函数接受3个参数，可以利用柯里化实现一个新的函数，将原函数的第一个参数固定为某个值，新函数可以继续接受两个参数完成原函数的运算。<br>事实上，这其实是 <strong><em>偏函数</em></strong> 。<br>要实现固定参数个数的函数柯里化，是没有问题的。但如果要实现可变参数个数的函数柯里化，这个可能么？<br>柯里化的思路，都是判断参数个数是否满足要求，满足则进行计算；否则返回一个函数，等待参数满足后进行计算。如果参数个数是可变的，那么怎么能实现呢？我怎么判断一个函数是应该输出一个数值，还是返回一个接受参数的函数呢？毕竟，我并不知道当前函数的返回结果，会被当成函数还是数值输出的。</p><p>也许面试官是刻意想让我通过沟通来搞清楚这些问题。但我就自以为需要允许接受多个参数，然后陷入了沉思。  </p><p>思考良久后，面试官也看出我的问题。于是给我精简了问题，只要写一个函数，能够通过如下测试即可:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curr(<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>) === <span class="number">24</span></span><br><span class="line">curr(<span class="number">7</span>, <span class="number">8</span>)(<span class="number">9</span>) === <span class="number">24</span></span><br><span class="line">curr(<span class="number">7</span>)(<span class="number">8</span>)(<span class="number">9</span>) === <span class="number">24</span></span><br></pre></td></tr></table></figure></p><p>这样一个函数肯定是能够实现的。但此时我的思路已经受到前面思考的影响，开始将思路放在把 <code>curr(7, 8, 9)</code> 转化为 <code>curr(7, 8)(9)</code>，然后把<code>curr(7, 8)(9)</code> 再转化为 <code>curr(7)(8)(9)</code> 上。而在转化之后，就需要在 <code>curr</code> 函数中判断输入参数为1个时返回一个函数，其中又返回一个返回函数的函数。嗯，光是把这个话打出来就够麻烦的了。  </p><p>这个时候，如果我能及时地想到，应该反过来，将 <code>curr(7)(8)(9)</code> 转为 <code>curr(7, 8)(9)</code>，再将 <code>curr(7, 8)(9)</code> 转为 <code>curr(7, 8, 9)</code>，然后将其计算输出，就能回归到柯里化的正确思路上来了。  </p><p>而且，一个函数 <code>curr(7, 8, 9)</code>，为什么要将其当成 <code>curr(7, 8)(9)</code> 执行呢？一个函数变成两个函数，完全是增加复杂度。</p><hr><p>其实，只要搞清楚，柯里化的目的是为了参数收集，而不是参数分散，就能想清楚问题。<br>既然是参数收集，一定要确定要收集的参数的个数。这个参数如何确定呢？就根据柯里化的目标函数的行参个数确定。<br>如此，柯里化返回这样一个函数: 只要其收集的参数个数不满足原函数行参的要求，就继续收集；否则调用原函数计算结果。<br>理清思路后，写代码就是极其简单的一件事:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span>(<span class="params">fn, ...args1</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">...args2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> args = args1.concat(args2)</span><br><span class="line">    <span class="keyword">if</span> (args.length &lt; fn.length) &#123;</span><br><span class="line">      <span class="keyword">return</span> curry(fn, ...args)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> fn(...args)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b, c</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b + c</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> curr = curry(add)</span><br></pre></td></tr></table></figure></p><p>甚至，使用箭头函数，可以以更简洁的形式编写:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn, ...args1</span>) =&gt;</span> (...args2) =&gt; (args1.concat(args2).length &lt; fn.length ? curry(fn, ...args1, ...args2) : fn(...args1, ...args2))</span><br></pre></td></tr></table></figure></p><h3 id="偏函数与柯里化"><a href="#偏函数与柯里化" class="headerlink" title="偏函数与柯里化"></a>偏函数与柯里化</h3><p>偏函数其实是固定了一个或多个参数的函数，它再接受参数后一定是返回一个计算结果，而非返回一个函数。<br>函数柯里化是将一个多参数的函数，转化为一个可以分步收集参数的函数。如果收集不满则不计算。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;记录下面试的车祸现场&lt;/p&gt;
&lt;h3 id=&quot;车祸现场&quot;&gt;&lt;a href=&quot;#车祸现场&quot; class=&quot;headerlink&quot; title=&quot;车祸现场&quot;&gt;&lt;/a&gt;车祸现场&lt;/h3&gt;&lt;p&gt;面试官出了如下一道题目:&lt;br&gt;封装一个模块，需要这个模块能够支持运算如 &lt;code&gt;c
      
    
    </summary>
    
    
      <category term="javascript 柯里化" scheme="https://ginobilee.github.io/tags/javascript-%E6%9F%AF%E9%87%8C%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>requestAnimationFrame是一个宏任务么</title>
    <link href="https://ginobilee.github.io/2019/02/01/requestAnimationFrame%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AE%8F%E4%BB%BB%E5%8A%A1%E4%B9%88/"/>
    <id>https://ginobilee.github.io/2019/02/01/requestAnimationFrame是一个宏任务么/</id>
    <published>2019-02-01T00:18:06.000Z</published>
    <updated>2019-02-05T03:13:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道浏览器在页面运行时利用Event loop来协调事件、交互、脚本、渲染、网络以及其它工作。Event loop的规则基于HTML的对应规范(引用1，后面提到的规范都是指它)。规范指出，一个event loop应该维护一个或多个任务队列(task queue)，以及一个微任务队列(microtask queue)。社区里一般将前者称为宏任务。    </p><p>规范中提到了几种常见的任务: DOM操作、用户交互、网络请求和浏览器history变更。它们都是我们常说的宏任务之属。而微任务就包括Promise、MutationObserver等等。一般的，只要一个api是异步操作，它必定是通过任务的机制运行的。那么对于 <code>requestAnimationFrame</code>(简称raf)，它是一个宏任务还是微任务呢？ </p><p>因为这篇文章严重依赖于前述规范，特意将对应章节进行了<a href="https://ginobilee.github.io/blog/2019/01/31/whatwg-html%E4%B8%AD%E7%9A%84event%20loop%E6%A8%A1%E5%9E%8B/">简单翻译</a>。</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>在讨论之前，我想先界定一下文章里要讨论到的几个概念:</p><ul><li>event loop: 这里专指html规范中的事件循环处理模型，为大多数现代浏览器所遵循。其对应的实体应该是浏览器中的渲染器，例如chrome中renderer进程的render线程</li><li>任务: 由event loop交给js引擎执行的一段代码</li><li>宏任务: 在event loop开始一次循环时会去检查任务队列，所有在这里去检查的任务队列，其任务为宏任务。</li><li>微任务: 每个event loop会维护一个 microtask queue，其中的任务称为微任务。</li></ul><p>为什么宏任务要如此界定呢？因为它其实标志了一个loop的开始。按照这里的概念，一个loop中，只会有一个宏任务被执行，多个宏任务一定是在多个loop中执行。当然，也可能因为任务队列都为空，一个loop中并没有宏任务执行。  </p><h3 id="event-loop-与-js引擎"><a href="#event-loop-与-js引擎" class="headerlink" title="event loop 与 js引擎"></a>event loop 与 js引擎</h3><p>需要说明，这里讨论的任务，是指event loop交给js引擎执行的任务。计算样式也可以当作一个任务(在chrome dev tool里可以清晰地看到占用了event loop)，但不在此处讨论之列。</p><p>而这些任务对于js引擎来说，其实是没有差别的。是什么样的任务，来自于哪个任务队列，对于js引擎其实并没有差别，对其来说都是通过execution context规范化的一个执行任务。而任务的管理以及何时执行，是由event loop维护的。所以html规范中也提到，浏览器可以给予一些任务(例如ui交互)更高的优先级。</p><p>关于任务的队列应该由谁来管理，在es6之前其实是不存在分歧的，因为彼时es规范中并没有任何关于队列的设计(没有异步的概念，之前的异步都是实现提供的)。但是从es6开始，es为了Promise引入了Job以及JobQueue。但是显然html并没有依照es的规范去实现，文档中也提到了:</p><blockquote><p>However, as of the time of this writing the definition of EnqueueJob in that specification(es规范) is not sufficiently flexible to integrate with HTML as a host environment.<br>The RunJobs abstract operation from the JavaScript specification must not be used by user agents.</p></blockquote><p>为何这样说呢？我是这样理解的: 现在的任务队列都是由event loop管理的，js引擎只是执行被交给的任务；如果按照es规范的理解，js引擎就需要自己维护任务任务，以及管理任务执行的顺序。这对于现在html的实现者们来说改动很大；而根据html给出的规范去实现，只要增加或重新管理任务队列就可以了，是兼容性最好的方案。</p><h3 id="微任务的执行时机"><a href="#微任务的执行时机" class="headerlink" title="微任务的执行时机"></a>微任务的执行时机</h3><p>微任务的执行时机有二，一个在event loop模型中显式地提到了，即循环的第6步(Microtasks: Perform a microtask checkpoint)；另一个在阐述 ‘perform a microtask checkpoint’ 逻辑时有提及:</p><blockquote><p>This(Run oldestMicrotask) might involve invoking scripted callbacks, which eventually calls the clean up after running script steps, which call this perform a microtask checkpoint algorithm again, which is why we use the performing a microtask checkpoint flag to avoid reentrancy.</p></blockquote><p>可见在执行完脚本回调后，还是会去执行微任务。既然如此，为什么还要在前述模型中加上专门的一步去执行微任务检查点呢，前面的宏任务执行完后本来也会去检查呐？</p><p>因为会有宏任务为空而微任务不为空的场景，这时就需要在处理过程中保证该微任务被会执行到。</p><p>总之，微任务会在以下时机执行:</p><ol><li>event loop中执行微任务检查点时</li><li>任何脚本任务结束的时候</li></ol><h3 id="requestAnimationFrame-的特性和执行时机"><a href="#requestAnimationFrame-的特性和执行时机" class="headerlink" title="requestAnimationFrame 的特性和执行时机"></a>requestAnimationFrame 的特性和执行时机</h3><p>特性:</p><ol><li>当开始执行它的回调时，在此刻之前注册的所有该类回调，会一次性执行完(一个loop内，这点很关键)</li><li>每个该类任务执行完，也会执行微任务(其实不能称为特性，毕竟所有脚本任务都是这样)</li><li>如果以自身递归调用的方式(raf回调内递归调用raf，使用该api的正确姿势)，它的触发时机总是与浏览器的渲染频率保持一致。</li></ol><p>执行时机:</p><ul><li>对照规范的步骤，在第10.10步。特别指出，在一个loop中，可能并不会执行这一步，只要浏览器任务不需要执行渲染，就会跳过。</li></ul><p>关于已注册的raf回调会在一个loop内执行完，规范是怎么说的:</p><p><blockquote><br>To run the animation frame callbacks for a target object target with a timestamp now:</blockquote></p><ol><li>Let callbacks be a clone of target’s map of animation frame callbacks.</li><li>Set target’s map of animation frame callbacks to a new empty ordered map.</li><li>For each handle → callback of callbacks, invoke callback, passing now as the only argument, and if an exception is thrown, report the exception.<br><br>之后又专门提到了，如果有多个回调执行，即便它们真正执行的时刻有差异，但它们取到的当前时间是同一个值。所以此处用意很明显，就是为了将多个回调设计成同步执行的效果。</li></ol><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>我们看到宏任务与raf任务有明显的差异:</p><ol><li>执行时机不同</li><li>raf任务队列被执行时，会将其此刻队列中所有任务都执行完</li></ol><p>所以raf任务不属于宏任务。而由于微任务的特殊性(单独的任务队列)，它显然更不是微任务。</p><p>所以它既不是宏任务，又不是微任务。那么它是什么？</p><p>任务。</p><p>其实，html规范中，至始至终找不到宏任务的描述。宏任务的概念，应该是社区为了区别微任务，而创造出来的。那么它是否还有意义呢？</p><p>我认为还是有意义的。它的意义在于前述的执行时机: 一个loop的起始阶段，且一个宏任务标志了一个loop。所以我们提宏任务时，就是指那些在loop开始时会去检查的任务，如此这个名称是有其独特意义的。</p><p>而更重要的是，宏任务的这个特性，对于流程控制是非常重要的。正因为它有标志一个loop开始的能力，所以它是适合作为流程控制来使用的。而非宏任务的任务就不适合。</p><p>所以 <code>setTimeout</code> 一定会被设计成宏任务，这可以保证它在任何地方调用，表现始终是一致的；也不会阻塞event loop。相反微任务只适合在一个任务结束后作为附加的流程控制，如果在微任务中反复触发其它微任务，就会阻塞掉event loop。下面的例子中，不论如何发起timer任务，它都不会彻底阻塞event loop；而微任务的递归调用则会彻底阻塞。</p><p>ps，篇尾引用3是一篇关于事件循环的很好的讨论，本文的缘起也正是在其中论到 requestAnimationFrame。</p><h3 id="todo"><a href="#todo" class="headerlink" title="todo:"></a>todo:</h3><ul><li style="list-style: none"><input type="checkbox"> chrome在一个loop的开始时检查哪些任务？它们是所谓的宏任务。</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref:"></a>ref:</h3><ol><li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">HTML - Web application APIs</a></li><li><a href="https://tc39.github.io/ecma262/#sec-jobs-and-job-queues" target="_blank" rel="noopener">ECMAScript - Jobs and Job Queues</a></li><li><a href="https://github.com/aooy/blog/issues/5" target="_blank" rel="noopener">从event loop规范探究javaScript异步及浏览器更新渲染时机 - 杨敬卓</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道浏览器在页面运行时利用Event loop来协调事件、交互、脚本、渲染、网络以及其它工作。Event loop的规则基于HTML的对应规范(引用1，后面提到的规范都是指它)。规范指出，一个event loop应该维护一个或多个任务队列(task queue)，以及一
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>whatwg-Html中的event loop模型</title>
    <link href="https://ginobilee.github.io/2019/01/31/whatwg-html%E4%B8%AD%E7%9A%84event%20loop%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ginobilee.github.io/2019/01/31/whatwg-html中的event loop模型/</id>
    <published>2019-01-31T11:17:41.000Z</published>
    <updated>2019-02-05T02:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="规范描述"><a href="#规范描述" class="headerlink" title="规范描述"></a>规范描述</h3><p>8.1.4.2. Processing model</p><p>An event loop must continually run through the following steps for as long as it exists:</p><ol><li><p>Let oldestTask be the oldest task on one of the event loop’s task queues, if any, ignoring, in the case of a browsing context event loop, tasks whose associated Documents are not fully active. The user agent may pick any task queue. If there is no task to select, then jump to the microtasks step below.</p><p>在该事件循环的任一(ua可以决定选择哪个任务队列)任务队列中查找最早的任务(忽略哪些关联Documents非活动中的任务)。如果任务队列都为空，跳转到微任务步骤。</p></li><li><p>Report the duration of time during which the user agent does not execute this loop by performing the following steps:</p><p>2.1 Set event loop begin to the current high resolution time.</p><p>2.2 If event loop end is set, then let top-level browsing contexts be the set of all top-level browsing contexts of all Document objects associated with the event loop. Report long tasks, passing in event loop end, event loop begin, and top-level browsing contexts.</p><p>通过以下步骤提醒ua没有执行此event loop的时间(<strong><em>question1</em></strong>):<br> 2.1 将event loop的开始事件(elb)设定为当前的高分辨率事件<br> 2.2 如果event loop的结束时间(ele)已设置，则设置顶级浏览环境集(tlbcs)为跟当前event loop关联的所有Document对象的顶级浏览环境。然后以ele，elb，tlbcs为参数执行耗时较长任务提醒。</p></li><li><p>Set the event loop’s currently running task to oldestTask.</p><p> 设置event loop的当前执行任务为步骤1中所选最早任务oldestTask。</p></li><li><p>Run oldestTask.</p><p>执行该任务。</p></li><li><p>Set the event loop’s currently running task back to null.</p><p> 将event loop的当前执行任务仍设置为null。</p></li><li><p>Remove oldestTask from its task queue.</p><p> 将前述执行任务从其task队列中移除。</p></li><li><p>Microtasks: Perform a microtask checkpoint.</p><p> 执行微任务检查点</p></li><li><p>Let now be the current high resolution time. </p><p>设置now为当前的该分辨率时间。</p></li><li><p>Report the task’s duration by performing the following steps:<br> 9.1 Let top-level browsing contexts be an empty set.<br> 9.2 For each environment settings object settings of oldestTask’s script evaluation environment settings object set, append setting’s top-level browsing context to top-level browsing contexts.<br> 9.3 Report long tasks, passing in event loop begin (repurposed as meaning the beginning of the task), now (the end time of the task), top-level browsing contexts, and oldestTask.</p><p>通过执行下列步骤计算该任务的执行时长:<br> 9.1 声明顶级浏览环境(tlbcs)为空队列。<br> 9.2 遍历步骤1中任务的脚本执行环境设置对象集，将该对象的顶级浏览环境添加如9.1节中队列。<br> 9.3 以ele(任务起始时间)，now(任务结束时间)，tlbcs，以及步骤1中任务为参数，执行耗时较长任务提醒。</p></li><li><p>Update the rendering: If this event loop is a browsing context event loop (as opposed to a worker event loop), then run the following substeps.</p><p>更新渲染视图：如果是在浏览环境(而非worker环境)，执行下列分步骤：</p><p>10.1 Let docs be the list of Document objects associated with the event loop in question, sorted arbitrarily except that the following conditions must be met:</p><p>设置docs为当前event loop相关的所有Document对象的列表，可以为任意顺序但需满足以下要求:</p><pre><code>a. Any Document B that is nested through a Document A must be listed after A in the list.被Document A嵌套的任意Document B必须在A之后b. If there are two documents A and B whose browsing contexts are both nested browsing contexts and their browsing context containers are both elements in the same Document C, then the order of A and B in the list must match the relative tree order of their respective browsing context containers in C.如果两个Document A and B的浏览环境是同一个Document C的浏览环境下的某个节点的嵌套环境，则A and B在列表中的顺序应该与它们在C中的顺序保持一致In the steps below that iterate over docs, each Document must be processed in the order it is found in the list.在下面的步骤中，docs中的每个元素都应该以其所处位置顺序执行</code></pre><p>10.2 Rendering opportunites: If there are browsing contexts browsingContexts that do not have a rendering opportunity, then remove from docs all Document objects whose browsing context is in browsingContexts.<br>A browsing context has a rendering opportunity if the user agent is currently able to present the contents of the browsing context to the user, accounting for hardware refresh rate constraints and user agent throttling for performance reasons, but considering content presentable even if it’s outside the viewport.<br>Browsing context rendering opportunities are determined based on hardware constraints such as display refresh rates and other factors such as page performance or whether the page is in the background. Rendering opportunities typically occur at regular intervals.</p><p>渲染机会: 从docs列表中删除其浏览环境没有渲染机会的元素。<br>如果ua当前可以向用户呈现浏览环境的的内容，则可以认为该浏览环境有渲染机会。ua会根据硬件刷新频率和性能考虑去决定是否给予渲染机会。<br>通常来说，渲染机会的有无取决于硬件限制如显示刷新频率，以及其它如页面性能或页面是否在后台的因素。渲染机会通常间隔固定的周期。   </p><p>10.3 Unnecessary rendering: If there are browsing contexts browsingContexts for which the user agent believes updating the rendering would have no visible effect and which possess no Document objects with a non-empty map of animation frame callbacks, then remove from docs all Document objects whose browsing context is in browsingContexts. Invoke the mark paint timing algorithm for each Document object removed.</p><p>不必要渲染: 如果ua认为更新某个浏览环境不会有可视的影响，并且其(浏览环境的)Document对象的动画帧回调(requestAminationFrame)都为空，则将该浏览环境相关的Document对象从docs队列中删除。对于每个删除的Document对象，触发绘制事件标记操作。</p><p>10.4 If there are browsing contexts browsingContexts for which the user agent believes it’s preferrable to skip updating the rendering for other reasons, then remove from docs all Document objects whose browsing context is in browsingContexts.</p><p>如果ua因为其它任何原因认为不需要渲染某个浏览环境，将与其相关的Document对象从docs中删除。</p><p>[Note]:<br>The step labeled Rendering opportunities prevents the user agent from updating the rendering when it is unable to present new content to the user (there’s no rendering opportunity).<br>The step labeled Unnecessary rendering prevents the user agent from updating the rendering when there’s no new content to draw.<br>This step enables the user agent to prevent the steps below from running for other reasons, for example, to ensure certain tasks are executed immediately after each other, with only microtask checkpoints interleaved (and without, e.g., animation frame callbacks interleaved). Concretely, a user agent might wish to coalesce timer callbacks together, with no intermediate rendering updates.</p><p>【注】:<br>标记渲染机会的步骤，用来阻止ua在没有能力呈现新内容的时候进行渲染。<br>不需要渲染，用来阻止ua在没有新的内容需要渲染时进行渲染。<br>而这一步，使得ua可以在其他情况下不执行后续的步骤。例如，为了使得一些任务被无间隔地连续执行，其间只有微任务检查点被执行(而不执行如动画帧回调步骤)。比如，ua可能希望将连续的定时回调连续执行完，中间不进行渲染更新。   </p><p>10.5 For each fully active Document in docs, run the resize steps for that Document, passing in now as the timestamp. </p><p>遍历docs中有效的Document，执行resize操作(计算并触发resize事件，并非执行resize更新)，时间戳为now。</p><p>10.6 For each fully active Document in docs, run the scroll steps for that Document, passing in now as the timestamp. </p><p>遍历docs中有效的Document，执行scroll操作(同10.5)，时间戳为now。</p><p>10.7 For each fully active Document in docs, evaluate media queries and report changes for that Document, passing in now as the timestamp. </p><p>遍历docs中有效的Document，执行媒体查询并报告变化，时间戳为now。</p><p>10.8 For each fully active Document in docs, update animations and send events for that Document, passing in now as the timestamp. </p><p>遍历docs中有效的Document，更新动画并发送事件，时间戳为now。</p><p>10.9 For each fully active Document in docs, run the fullscreen rendering steps for that Document, passing in now as the timestamp.</p><p>遍历docs中有效的Document，执行全屏事件通知步骤，时间戳为now。</p><p>10.10 For each fully active Document in docs, run the animation frame callbacks for that Document, passing in now as the timestamp.</p><p>遍历docs中有效的Document，执行动画帧回调(<strong><em>me: requestAnimationFrame注册的回调</em></strong>)，时间戳为now。</p><p>10.11 For each fully active Document in docs, run the update intersection observations steps for that Document, passing in now as the timestamp.</p><p>遍历docs中有效的Document，执行交互检测步骤，时间戳为now。</p><p>10.12 Invoke the mark paint timing algorithm for each Document object in docs.</p><p>遍历docs中元素，触发绘制时机标志算法。</p><p>10.13 For each fully active Document in docs, update the rendering or user interface of that Document and its browsing context to reflect the current state.</p><p>遍历docs中有效的Document，根据其当前状态，更新这个Document及其浏览环境的渲染或ui。</p></li><li><p>If this is a browsing context event loop (as opposed to a worker event loop), and there are no tasks in the event loop’s task queues which are associated with a Document that is fully active, and the event loop’s microtask queue is empty, and none of the browsing contexts have a rendering opportunity, then for each browsing context, run the steps in the start an idle period algorithm, passing the Window associated with that browsing context.</p><p>如果这是浏览环境的事件循环(而非worker)，且当前任务队列为空，微任务队列也为空，浏览环境也都没有渲染机会，则执行开始空闲时间逻辑(requestIdleCallback)。</p></li><li><p>Report the duration of the update the rendering step by performing the following steps:<br>12.1 Let rendering end time be the current high resolution time.<br>12.2 Let top-level browsing contexts be the set of all top-level browsing contexts of all fully active Documents in docs.<br>12.3 Report long tasks, passing in now (repurposed as meaning the beginning of the update the rendering step), rendering end time, and top-level browsing contexts.   </p><p>根据以下步骤计算更新渲染的持续时间:<br>12.1 设置渲染结束时间(ret)为当前的高分辨率时间<br>12.2 设置顶级浏览环境集(tlbcs)为当前相关的所有顶级浏览环境<br>12.3 以相应参数计算耗时较长任务</p></li><li><p>If this is a worker event loop (i.e., one running for a WorkerGlobalScope):</p><ol><li>If this is a supported DedicatedWorkerGlobalScope and the user agent believes that it would benefit from having its rendering updated at this time, then:</li><li>Let now be the current high resolution time. </li><li>Run the animation frame callbacks for that DedicatedWorkerGlobalScope, passing in now as the timestamp.</li><li>Update the rendering of that dedicated worker to reflect the current state.</li><li>If there are no tasks in the event loop’s task queues and the WorkerGlobalScope object’s closing flag is true, then destroy the event loop, aborting these steps, resuming the run a worker steps described in the Web workers section below.</li></ol><p>如果是worker的event loop:   </p><ol><li>如果是DedicatedWorkerGlobalScope，且ua相信它应该更新渲染(<strong><em>todo1</em></strong>)，则:</li><li>声明当前高分辨率时间now</li><li>为其执行动画帧回调，传入当前时间作为参数</li><li>更新对应的渲染</li><li>如果任务队列中没有任务，且WorkerGlobalScope对象的关闭标志为true，则销毁这个event loop，放弃这些步骤，恢复运行worker步骤。</li></ol></li><li><p>Set event loop end to be the current high resolution time.</p><p>设置event loop结束时间为当前的高分辨率时间。</p></li></ol><h3 id="questions"><a href="#questions" class="headerlink" title="questions:"></a>questions:</h3><ol><li><code>the duration of time during which the user agent does not execute this loop</code> 这里是计算什么？没有太懂</li><li><p>what is browsing context?<br> 基本上是同步于renderer process的一个抽象。规范如是阐述:   </p> <blockquote><br>   A browsing context is an environment in which Document objects are presented to the user.<br><br>   Note:<br>   A tab or window in a Web browser typically contains a browsing context, as does an iframe or frames in a frameset.<br><br>   A browsing context has a corresponding WindowProxy object.<br><br>   A browsing context has a session history, which lists the Document objects that the browsing context has presented, is presenting, or will present. At any time, one Document in each browsing context is designated the active document. A Document’s browsing context is that browsing context whose session history contains the Document, if any. (A Document created using an API such as createDocument() has no browsing context.) Each Document in a browsing context is associated with a Window object.<br> </blockquote></li></ol><h3 id="todos"><a href="#todos" class="headerlink" title="todos:"></a>todos:</h3><ul><li style="list-style: none"><input type="checkbox"> DedicatedWorkerGlobalScope为什么可以更新渲染？</li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref:"></a>ref:</h3><p><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">HTML-whatwg-event loop</a><br><a href="https://html.spec.whatwg.org/multipage/browsers.html#browsing-context" target="_blank" rel="noopener">HTML-whatwg-browsing-context</a><br><a href="https://www.w3.org/TR/html52/webappapis.html#event-loops-processing-model" target="_blank" rel="noopener">HTML-w3c-event loop</a><br><a href="https://www.w3.org/TR/html52/browsers.html#browsing-context" target="_blank" rel="noopener">HTML-W3C-browsing-context</a><br><a href="https://fullscreen.spec.whatwg.org/#run-the-fullscreen-steps" target="_blank" rel="noopener">Fullscreen API - whatwg</a><br><a href="https://drafts.csswg.org/web-animations/#update-animations-and-send-events" target="_blank" rel="noopener">w3c - Web Animations</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;规范描述&quot;&gt;&lt;a href=&quot;#规范描述&quot; class=&quot;headerlink&quot; title=&quot;规范描述&quot;&gt;&lt;/a&gt;规范描述&lt;/h3&gt;&lt;p&gt;8.1.4.2. Processing model&lt;/p&gt;
&lt;p&gt;An event loop must continuall
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>How chrome works?(part1)</title>
    <link href="https://ginobilee.github.io/2019/01/29/How%20chrome%20works(part1)/"/>
    <id>https://ginobilee.github.io/2019/01/29/How chrome works(part1)/</id>
    <published>2019-01-29T14:41:38.000Z</published>
    <updated>2019-01-31T01:17:47.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="功能结构-进程-线程视角"><a href="#功能结构-进程-线程视角" class="headerlink" title="功能结构(进程/线程视角)"></a>功能结构(进程/线程视角)</h3><p>chrome采用多进程结构:</p><ol><li>主进程(也称为browse进程或browser)，它主要执行:<ol><li>运行 UI</li><li>管理 tab(renderer) 和 插件进程</li><li>部分与操作系统的交互，如I/O</li></ol></li><li>renderer进程(后面也称为renderer)，即渲染进程，可以认为对应于每个tab有一个renderer进程。renderer进程使用Blink布局引擎来对 HTML/CSS/脚本 进行解析和布局，chrome会为每个renderer进程实例化一个Blink引擎实例。</li></ol><blockquote><p> (Blink) The web engine responsible for turning HTML, CSS and scripts into paint commands and other state changes. </p></blockquote><p>架构图1(来自谷歌):<br><img src="https://raw.githubusercontent.com/ginobilee/blog/master/source/images/chrome-structure-1.png"><br>图中以(process boundary)为边界分为上下三层，上三层属于browser进程；下三层是renderer进程。</p><h4 id="browser进程"><a href="#browser进程" class="headerlink" title="browser进程"></a>browser进程</h4><p>browser进程管理各个renderer进程，renderer进程之间是相互隔离的，每个render进程对于系统的访问也受browser限制，这是为了安全和性能的考虑。  </p><p>browser进程内主要维护两个线程(不止): 主线程(main thread)和I/O线程。  </p><p>I/O线程主要负责: </p><ol><li>与系统I/O交互，如网络请求</li><li>与renderer通信。I/O线程会为每一个renderer维护一个IPC::Channel，它来负责renderer与browser之间的通信。  </li></ol><p>main thread是执行绘制的主体，图1中上三层，主要就是它的工作。可以看到从上到下分为三层:</p><ol><li>Browser: Represents the browser window, it contains multiple WebContentses.(代表浏览器窗口，包含多个 WebContentses </li><li>WebContents: A reusable component that is the main class of the Content module. It’s easily embeddable to allow multiprocess rendering of HTML into a view.<blockquote><p>WebContents represents the contents of a webpage. It is the top-level object in the content module, and has the responsibility of displaying a web page in a rectangular view.</p></blockquote></li><li>Renderer / Render host: This is Chromium’s “multi-process embedding layer.” It proxies notifications and commands across the process boundary.(相当于多个renderer进程在browser中的代理)</li></ol><p>browser进程示意(来自谷歌):<br><img src="https://raw.githubusercontent.com/ginobilee/blog/master/source/images/chrome-renderer-process.png"></p><h4 id="renderer进程"><a href="#renderer进程" class="headerlink" title="renderer进程"></a>renderer进程</h4><p>每个renderer进程维护两个线程: main thread和render thread(当提到renderer时总是指进程，线程用render thread区分)。</p><p>main thread 主要负责对browser通信</p><p>render thread 执行渲染(并非在屏幕上绘制，那是browser进程的工作。这里指 render tree的管理。)的工作，这个线程的实体应该就是前述Blink的实例。它应该是常说的event loop的运行实体，包含两个重要的部分: 渲染引擎与js引擎。</p><p>renderer的main thread的作用之一是在render thread与browser进行同步交互时对于其它消息的保存。例如脚本中通过<code>document.cookie</code>获取cookie，请求通过main thread发送给browser(browser进程的CookieMonster对象管理着cookie)，同时该render thread的操作会暂停(同步请求，相当于event loop停住了)；等到browser将结果传回来，render再恢复运行。在render线程阻塞的过程中renderer收到的消息，都被main thread所缓存，在render线程收到cookie请求后再依次传给render thread。  </p><p>renderer进程示意(来自谷歌):<br><img src="https://raw.githubusercontent.com/ginobilee/blog/master/source/images/chrome-renderer-process.png"></p><h4 id="renderer与browser的交互"><a href="#renderer与browser的交互" class="headerlink" title="renderer与browser的交互"></a>renderer与browser的交互</h4><p>每个renderer中会维护一个全局的(对该进程而言) RenderProcess 对象，它与 browser 进程进行通信，并维护全局状态。针对每个renderer，browser维护一个对应的 RenderProcessHost ，它来维护browser的相关状态，并与renderer通信。<br>RenderViewHost 和 RenderWidgetHost (browser进程) 可以认为是 RenderView 和 RenderWidget （renderer进程的render线程内)的代理。<br>交互主要对接在图1中的中间两层。  </p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以点击事件为例。如果我们在鼠标点击事件上上绑定了回调，回调中发起了一个网络请求，那么处理的流程应该就是:</p><ol><li>browser管理的ui线程收到click事件，将其发给renderer</li><li>renderer收到事件后，会将对应的回调推入对应的任务队列；当event loop有空时，开始调用js engine执行此任务(这里还可以更详细，event loop与js engine的运行逻辑)；js engine执行，发出网络请求；renderer将此请求发给browser的I/O线程</li><li>browser通过I/O线程调用系统I/O发起请求</li><li>browser收到响应后，将response回传renderer。于是renderer像处理click事件一样，将其推入对应的任务队列，等待event loop调起js engine执行。</li></ol><blockquote><p>Each request(已经到了browser管理中) is then converted into a URLRequest object, which in turn forwards it to its internal URLRequestJob that implements the specific protocol desired. When the URLRequest generates notifications, its ResourceDispatcherHost::Receiver and request ID are used to send the notification to the correct RenderProcessHost for sending back to the renderer. </p></blockquote><h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><ul><li style="list-style: none"><input type="checkbox"> Blink 与 Webkit 的角色一样么？区别是什么？<br> 角色一样。区别？</li><li style="list-style: none"><input type="checkbox"> WebContents 层的引擎是什么，是不是重绘总是发生在 renderer 进程中，所以会影响性能；而css的transform的改变发生在browser的WebContents层，所以不会影响性能？</li><li style="list-style: none"><input type="checkbox"> event loop的一个loop可以认为是render thread内的一次循环标志了一个loop。一个渲染帧呢？比如会触发 requestAnimationFrame 回调 的一个帧，对于chrome来说以什么标志一个帧，或者说是帧之间的边界？</li><li style="list-style: none"><input type="checkbox"> 总结完后再去看<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/threading_and_tasks.md" target="_blank" rel="noopener">Threading and Tasks in Chrome</a>，感觉这里参考的三篇文档只是一个抽象的描述，具体实现要复杂的多。加油  </li><li style="list-style: none"><input type="checkbox"> 在chrome dev tool中，一个loop中进行的 Recalculate Style/Update Style/Paint/Composite ，以及raster(栅格化)和gpu分别对应这里哪一块?  </li></ul><h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p><a href="https://www.chromium.org/developers/design-documents/multi-process-resource-loading" target="_blank" rel="noopener">Multi-process Resource Loading</a><br><a href="https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome" target="_blank" rel="noopener">How Chromium Displays Web Pages</a><br><a href="https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code" target="_blank" rel="noopener">Getting Around the Chromium Source Code Directory Structure</a><br><a href="https://chromium.googlesource.com/chromium/src/+/master/docs/threading_and_tasks.md" target="_blank" rel="noopener">Threading and Tasks in Chrome</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;功能结构-进程-线程视角&quot;&gt;&lt;a href=&quot;#功能结构-进程-线程视角&quot; class=&quot;headerlink&quot; title=&quot;功能结构(进程/线程视角)&quot;&gt;&lt;/a&gt;功能结构(进程/线程视角)&lt;/h3&gt;&lt;p&gt;chrome采用多进程结构:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
      
    
    </summary>
    
    
      <category term="chrome" scheme="https://ginobilee.github.io/tags/chrome/"/>
    
  </entry>
  
  <entry>
    <title>webpack中异步加载的逻辑</title>
    <link href="https://ginobilee.github.io/2019/01/28/webpack%E4%B8%AD%E5%BC%82%E6%AD%A5%E5%8A%A0%E8%BD%BD%E7%9A%84%E9%80%BB%E8%BE%91/"/>
    <id>https://ginobilee.github.io/2019/01/28/webpack中异步加载的逻辑/</id>
    <published>2019-01-28T03:17:41.000Z</published>
    <updated>2019-01-28T03:23:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="webpack打包后的入口文件"><a href="#webpack打包后的入口文件" class="headerlink" title="webpack打包后的入口文件"></a>webpack打包后的入口文件</h3><p>webpack的输出是一个立即执行表达式。<br>其参数是一个对象(modules)。对象的键是文件名字，值是一个函数，函数体就是 <code>evel(//原模块的内容)</code>。<br>立即执行表达式的函数体部分是加载模块的逻辑。这个函数的行参接收的就是上面的<code>modules</code>。在函数体中，用 <code>installedModules</code> 来对模块的 <code>exports</code> 做缓存。</p><h3 id="modules-和-installedModules"><a href="#modules-和-installedModules" class="headerlink" title="modules 和 installedModules"></a><code>modules</code> 和 <code>installedModules</code></h3><p>其中两个关键的对象: <code>modules</code> 和 <code>installedModules</code> :</p><ol><li><code>modules</code> 对模块的源码做缓存(即使是异步加载的模块，也会在加载后放入 <code>modules</code> 中)</li><li><code>installedModules</code> :<ol><li>对模块解析后的输出(<code>exports</code>)做缓存，这样在解析过一次后就不再需要进行再次解析</li><li>对异步加载的文件用 0 标记已经被加载。</li></ol></li></ol><h3 id="异步文件的加载"><a href="#异步文件的加载" class="headerlink" title="异步文件的加载"></a>异步文件的加载</h3><p>一个异步文件的加载，可以分成以下步骤:</p><ol><li>用 <code>__webpack_require__.e</code> 加载该文件，传入的参数是文件的名字id(比如打包成了<code>0.[chunkname].js</code>，这里传入<code>0</code>，<code>chunkname</code>在 <code>__webpack_require__.e</code>内以对象映射的方式(<code>{0: [chunkname]}</code>)匹配)。它执行了以下操作:<ol><li>将该文件内的  <code>exports.modules</code> 以源码形式存入 <code>modules</code> 对象中，使得其他文件中的模块源码也增加到了本地的 <code>modules</code> 缓存中；</li><li>将该文件对应的 <code>chunkId</code> 添加在 <code>installedModules</code>中，值为 0 标记该文件已经被加载。这样后面其它文件再去请求同样的文件时不会重复执行。</li></ol></li><li>在异步加载该文件的模块内，用 <code>__webpack_require__</code> 加载对应的模块，即 <code>__webpack_require__.e(/*! import() */ 0).then(__webpack_require__.bind(null, /*! ./b */ \&quot;./b.js\&quot;))</code>。从注释中也可以看出webpack将 <code>import()</code> 语句转成了 <code>__webpack_require__.e()</code>，这个函数返回一个 promise。  </li></ol><h3 id="异步加载函数-webpack-require-e"><a href="#异步加载函数-webpack-require-e" class="headerlink" title="异步加载函数 __webpack_require__.e"></a>异步加载函数 <code>__webpack_require__.e</code></h3><p><code>__webpack_require__.e</code>的关键代码如下:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">var</span> chunk = <span class="built_in">require</span>(<span class="string">"./"</span> + (&#123;&#125;[chunkId]||chunkId) + <span class="string">"."</span> + &#123;<span class="string">"0"</span>:<span class="string">"081d69d7289d20fd61af"</span>&#125;[chunkId] + <span class="string">".js"</span>);</span><br><span class="line"><span class="keyword">var</span> moreModules = chunk.modules, chunkIds = chunk.ids;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> moduleId <span class="keyword">in</span> moreModules) &#123;</span><br><span class="line">    modules[moduleId] = moreModules[moduleId];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; chunkIds.length; i++)</span><br><span class="line">    installedChunks[chunkIds[i]] = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// ...</span></span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;webpack打包后的入口文件&quot;&gt;&lt;a href=&quot;#webpack打包后的入口文件&quot; class=&quot;headerlink&quot; title=&quot;webpack打包后的入口文件&quot;&gt;&lt;/a&gt;webpack打包后的入口文件&lt;/h3&gt;&lt;p&gt;webpack的输出是一个立即执行表
      
    
    </summary>
    
    
      <category term="webpack" scheme="https://ginobilee.github.io/tags/webpack/"/>
    
  </entry>
  
  <entry>
    <title>fetch返回一个promise，所以它在收到响应时直接进入微任务队列么？</title>
    <link href="https://ginobilee.github.io/2019/01/28/xhr%20vs%20fetch/"/>
    <id>https://ginobilee.github.io/2019/01/28/xhr vs fetch/</id>
    <published>2019-01-28T01:17:41.000Z</published>
    <updated>2019-02-01T14:19:12.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章起源于 XHR(XMLHttpRequest) 与 Fetch 的比较。Fetch 的重大改变之一就是它返回一个 Promise，而在 XHR 中是利用回调的方式进行响应。XHR 响应后，会将对应的回调推入对应于网络请求的task(是一个macro task)中。而 Fetch 返回一个promise，浏览器会把 promise 的回调放入微任务中，那么是不是 Fetch 的响应也会更早的执行呢？   </p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>为了验证 Fetch 的回调是不是直接放入微任务中，我设计了这样一个实验：同时用fetch发出两个相同的请求，在其回调中，利用while循环阻塞一定时间，之后再直接resolve一个promise。如果fetch的回调直接放入微任务中，在前一个请求的响应被阻塞的时候，后一个响应应该也触发了，那么后一个响应的回调会直接进入微任务队列中，从而早于在前一个fetch回调中resolve的promise被执行。结果是不是这样呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = fetch(<span class="string">"http://baike.baidu.com/api/openapi/BaikeLemmaCardApi?scope=103&amp;format=json&amp;appid=379020&amp;bk_key=shoe&amp;bk_length=60"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = fetch(<span class="string">"http://baike.baidu.com/api/openapi/BaikeLemmaCardApi?scope=103&amp;format=json&amp;appid=379020&amp;bk_key=shoe&amp;bk_length=60"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span></span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="comment">// wait for 3 s</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p1 callback, before wait, and now is : "</span>, start)</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() &lt; start + <span class="number">5</span> * <span class="number">1000</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p1 callback, after wait, and now is : "</span>, start)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise initiated in p1 fire"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="comment">// wait for 3 s</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p2 callback, before wait, and now is : "</span>, start)</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() &lt; start + <span class="number">5</span> * <span class="number">1000</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p2 callback, after wait, and now is : "</span>, start)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise initiated in p2 fire"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// in p2 callback, before wait, and now is :  1548601804877</span></span><br><span class="line"><span class="comment">// in p2 callback, after wait, and now is :  1548601804877</span></span><br><span class="line"><span class="comment">// promise initiated in p2 fire</span></span><br><span class="line"><span class="comment">// in p1 callback, before wait, and now is :  1548601809880</span></span><br><span class="line"><span class="comment">// in p1 callback, after wait, and now is :  1548601809880</span></span><br><span class="line"><span class="comment">// promise initiated in p1 fire</span></span><br></pre></td></tr></table></figure></p><p>显然，输出并非如此，在首先响应的fetch的回调中，触发的promise仍然早于另外一个fetch的回调被调用了。<br>这样的结果显然跟 XHR 没有区别。那么是不是两个请求的响应时间差超过了3s呢？尝试加大<code>while</code>循环的时延后，表现仍然一如既往。</p><h3 id="对比-MutationObserver"><a href="#对比-MutationObserver" class="headerlink" title="对比 MutationObserver"></a>对比 MutationObserver</h3><p>MutationObserver 的回调也会放入微任务，它的表现会跟fetch一样么？<br>同样，为一个dom元素绑定两个监听事件，在其回调中触发一个微任务，观察触发顺序。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'con'</span> <span class="attr">name</span>=<span class="string">'name'</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> log = <span class="built_in">console</span>.log</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">cbFactory</span>(<span class="params">name</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">mutationList, observer</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      mutationList.forEach(<span class="function">(<span class="params">mutation</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">switch</span>(mutation.type) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">case</span> <span class="string">'attributes'</span>:</span></span><br><span class="line"><span class="javascript">            log(<span class="string">'attribute change : '</span>, name)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">              log(<span class="string">'Promise: '</span>, name)</span></span><br><span class="line"><span class="undefined">            &#125;)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> targetNode = <span class="built_in">document</span>.querySelector(<span class="string">"#con"</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> observerOptions = &#123;</span></span><br><span class="line"><span class="javascript">    attributes: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(cbFactory(<span class="number">1</span>));</span></span><br><span class="line"><span class="undefined">  observer.observe(targetNode, observerOptions);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> observe2 = <span class="keyword">new</span> MutationObserver(cbFactory(<span class="number">2</span>))</span></span><br><span class="line"><span class="undefined">  observe2.observe(targetNode, observerOptions)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  targetNode.attributes.removeNamedItem(<span class="string">'name'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">attribute change :  1</span><br><span class="line">attribute change :  2</span><br><span class="line">Promise:  1</span><br><span class="line">Promise:  2</span><br></pre></td></tr></table></figure></p><p>显然与浏览器中fetch表现不一致。看起来，MutationObserver 的回调是一个“干净”的微任务。<br>其实，这也很好理解。MutationObserver 是一个纯浏览器内事件，浏览器只需要在监听到事件发生后，将对应的回调推入微任务队列就可以了。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>到这里足可看出，fetch 不是一个单纯的promise。关键在于，fetch会发起一个网络请求，当请求被响应时，怎么通知主线程来处理回调? 在 XHR 中，是将回调放入对应于网络请求的任务队列中，fetch是否也是这样呢？<br>查找 WHATWG 的对应规范，其中确实提到收到响应后，会在网络请求的任务队列中推入任务:   </p><blockquote><p>Queue a task to run an operation on request’s client’s responsible event loop using the networking task source.</p></blockquote><p>即将task推入对应的event loop的网络请求任务队列中。</p><p>我推测fetch的工作模式实际上是:</p><ol><li>请求被响应，在网络请求任务队列中推入一个任务。这个任务应该是执行 enqueue promise的操作(虽然规范中并没有提到)</li><li>event loop执行到网络请求任务队列的该任务时，把对应promise的回调推入微任务</li><li>event loop在执行到当前循环的微任务检查点时执行该promise的响应</li></ol><p>即，对于fetch，其实浏览器还是沿用一样的网络请求处理逻辑，只是在响应时，推入对应任务队列的任务，执行了将promise回调推入微任务的动作。  </p><h3 id="搞清楚这个问题有什么用？"><a href="#搞清楚这个问题有什么用？" class="headerlink" title="搞清楚这个问题有什么用？"></a>搞清楚这个问题有什么用？</h3><p>在使用 xhr 时，在其回调中利用 promise 将任务放入微任务队列中，这个微任务一定会早于其它触发的 xhr 执行；如果对 fetch 上述模型不了解，会去想是否 fetch 中新触发的 promise 会晚于其它并发收到 fetch 的响应？在对处理顺序有要求的场合，这里就会影响到是否可以在回调中使用 promise 进行异步处理。搞清楚多个 fetch 的回调仍然会走 event loop 的多个loop，就明白是否会对程序的执行流产生影响。   </p><hr><p>ref:   </p><ol><li><a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noopener">Fetch Living Standard</a>   </li><li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">event loop in HTML</a></li><li><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/MutationObserver" target="_blank" rel="noopener">MDN MutationObserver</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章起源于 XHR(XMLHttpRequest) 与 Fetch 的比较。Fetch 的重大改变之一就是它返回一个 Promise，而在 XHR 中是利用回调的方式进行响应。XHR 响应后，会将对应的回调推入对应于网络请求的task(是一个macro task)中。而 F
      
    
    </summary>
    
    
      <category term="fetch promise" scheme="https://ginobilee.github.io/tags/fetch-promise/"/>
    
  </entry>
  
  <entry>
    <title>我欲建立的知识结构模型</title>
    <link href="https://ginobilee.github.io/2019/01/25/%E6%88%91%E6%AC%B2%E5%BB%BA%E7%AB%8B%E7%9A%84%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ginobilee.github.io/2019/01/25/我欲建立的知识结构模型/</id>
    <published>2019-01-25T07:38:19.000Z</published>
    <updated>2019-01-25T09:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起源及程序员的一般知识结构"><a href="#起源及程序员的一般知识结构" class="headerlink" title="起源及程序员的一般知识结构"></a>起源及程序员的一般知识结构</h2><p>在跟踪winter的《重学前端》系列时的所想。  </p><p>winter提到，要建立自己的知识架构。这刚好是我最近在思考的问题。  </p><p>一个前端，首先是一个程序员。程序员的基本知识架构，前端也是应该具备的，比如数据结构、算法、编译原理、操作系统等等。但这些更是一个人的能力素质基础，虽然决定了一个人在技术上能够达到的高度，却不一定能在工作中立即解决面对的问题。这些素质我想可以认为是一个前端(以及程序员)在”道”这个层次的要求。而前端作为一个工程实践性远高于理论探索性的职业，从业者和招聘者也自然会忽视这方面的要求，而对具体的职业技能更为看重。  </p><p>大佬也提到这门课不会关注前面说的计算机基础，而是重点关注前端领域内的技能。我认为，在前端领域内，也可以划分为基础素质或曰能力，以及实践技能。基础素质按照大佬的这个划分已经是极好的了。javascript/html/css可以认为是前端从业者的工具，浏览器/node.js这些是前端工作的宿主，工程化是前端从业者利用工具在宿主上实现特定工程目标这一个过程的经验总结。这些可以认为是一个前端在”法”这个层次的要求。  </p><p>按照道、法、术的层次，现在社区中充斥的，”xx天带你撸一个xx”之类的文章或视频，基本上都是”术”这个层次。法与术，不同的人会有不同的见解。对于a来说认为是法的东西，可能对于b来说只是术，对于c来说已经是道了。我想这也能反映出一个人的认知水平。  </p><h2 id="javascript的知识结构"><a href="#javascript的知识结构" class="headerlink" title="javascript的知识结构"></a>javascript的知识结构</h2><p>具体到javascript这一块，我之前的认知将其从结构上分为这么两块: 语法+运行时。我所划分的语法就是指es规范，其实是大佬所讲的一整个javascript这块。而运行时是规范中implementation的概念，是浏览器(html标准)/node.js中对于规范的实现，以及这些特定实现中交织的其它(非es规范)部分。举例来说，大家经常提到的eventloop，其实是html或node.js中的机制，两者分别有对应的规范/实现。而在es规范中，其实只是在es6加入模块化和Promise之后才有相关的概念Job。而对于html规范中的eventloop，js的运行(脚本执行/多个JobQueue的执行)只是其中一部分，此外还有对于渲染的处理(resize/paint/requestAnimationFrame等等)。我觉得将这些概念区分清楚是大有裨益于自己知识结构的建立的，它们就像知识之间的边界，对于不同的知识有清晰的边界，才会有更清晰的认知。  </p><p>大佬将javascript的知识结构划分为 文法/语义/运行时 是一种更精准的划分。  </p><h2 id="我对于前端知识结构的认识"><a href="#我对于前端知识结构的认识" class="headerlink" title="我对于前端知识结构的认识"></a>我对于前端知识结构的认识</h2><p>我所认为的前端知识架构，其实从一个简单的问题就可以包括进来:一个页面从输入地址到可交互，有哪些过程？  </p><p>这个问题可以不停地深入下去，找到所有的细节；同时所有问题又都可以在这个问题上找到它的位置。比如从问题本身出发，牵涉到的问题就有:  </p><ol><li>网络。域名怎么转换为服务器地址?这里会不会有安全性问题？域名解析服务会不会挂掉(我们遇到过)?</li><li>http协议。一个请求的结构？缓存规则？service worker？动静分离？不同的状态码什么含义？跨域？动词方法？restful接口？预检请求？性能优化中相关措施？https？</li><li>浏览器的渲染过程。这是一个大的话题，里面信息量巨大。如何解析html？文档模型与渲染树？脚本的加载？如何优化脚本的加载？多个脚本加载有没有优化方法？为什么要以某种模式优化(比如script放在body后)？为什么处理js要阻塞渲染，浏览器为何如此设计，为何不像客户端一样分成两个线程？加载脚本的网络请求是同一个线程么？那多个脚本的加载是同一个线程么？脚本加载完后如何与渲染线程交互？把脚本放在html加载与放在另一个脚本里加载有区别么？js的模块化？要不要将多个请求分成多个域名，为什么？浏览器的事件循环模型？不同浏览器的兼容性？如何抹平差异？</li><li>页面的交互一般是通过js实现的，那么js的领域都可以牵涉进来了。<ol><li>js的语法和运行时</li><li>js可以访问到的宿主接口(这其实也是很大的一个范畴，比如setTimeout/setInterval都是其中的。而只是xhr/fetch就可以牵出许多问题。比如异步网络请求是在单独的线程执行的么？那么请求结果如何通知主线程？fetch请求会返回一个promise，那么它是放在Mircotask Queue的么？)</li><li>不同宿主对于js的实现？</li><li>es规范中的新语法？如何应用在没有提供实现的宿主中？<br>…</li></ol></li><li>内容结构和样式的组织: html与css。</li><li>站点结构。如何部署？如何最小更新？这里又牵涉到了工程化问题的一部分。<br>…</li></ol><p>回过头来，再将知识规划成上面这一个体系的话，可以将所有东西都划进对应的slot内。  </p><p>比如模块化，他应该是属于什么问题？它从一个工程问题而来(es规范最初没有模块化，只有社区的实践，require这样的语法在规范中是没有的)，演变成一个es规范的问题。而且我们可以看到，对于这个问题，es规范的解决是优于社区的解决方案的。规范的解决思路，是从语言的层面上去提供能力，社区的解决思路还是停留在解决问题。当然，规范的解决思路从社区中汲取了营养，这是毫无疑问的。   </p><p>总之，我想建立的知识体系，是对应这样一个流程的: 用这一个问题可以把所有这些概念包容进去；对于任何问题，又都可以在这个问题中找到它的坑位。   </p><h2 id="我想建立的知识结构"><a href="#我想建立的知识结构" class="headerlink" title="我想建立的知识结构"></a>我想建立的知识结构</h2><p>我想建立的是:  </p><ol><li>首先明白es规范对于问题是怎么阐述的。这里就包括 语法/算法。</li><li>各个宿主中是如何实现的。比如Promise，浏览器的实现？浏览器又是如何利用这些装置提供api的，比如fetch？</li><li>从第1个问题引申出的是js运行时的一个概览，明白从模块/函数到语句的运行过程；从第2个问题引申出的是浏览器或其它宿主是如何实现的？它们的内部架构？</li><li>明白了这两块，就基本明了了前端的基础。再辅以网络/更外层的宿主(浏览器可以认为是js宿主，操作系统可以认为是浏览器宿主，服务器可以认为是操作系统宿主)的原理，这个就是不断扩展边界的过程了。</li></ol><p>ref:    </p><ol><li><a href="https://time.geekbang.org/column/article/77749" target="_blank" rel="noopener">winter的分享之明确你的前端学习路线与方法</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起源及程序员的一般知识结构&quot;&gt;&lt;a href=&quot;#起源及程序员的一般知识结构&quot; class=&quot;headerlink&quot; title=&quot;起源及程序员的一般知识结构&quot;&gt;&lt;/a&gt;起源及程序员的一般知识结构&lt;/h2&gt;&lt;p&gt;在跟踪winter的《重学前端》系列时的所想。  &lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从规范看赋值表达式的解析</title>
    <link href="https://ginobilee.github.io/2019/01/24/%E4%BB%8E%E8%A7%84%E8%8C%83%E7%9C%8B%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>https://ginobilee.github.io/2019/01/24/从规范看赋值表达式的解析/</id>
    <published>2019-01-24T01:23:04.000Z</published>
    <updated>2019-01-24T07:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>从一道常见的面试题开始:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = a.y = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.x);</span><br><span class="line"><span class="built_in">console</span>.log(b.y);</span><br></pre></td></tr></table></figure></p><p>显然，关键点在于最后一个语句的执行。这个语句的执行主要涉及了 <em>属性获取表达式</em> 和 <em>赋值表达式</em>，先去规范里看对于这两种语法及其执行的规定。</p><h2 id="1-赋值表达式"><a href="#1-赋值表达式" class="headerlink" title="1. 赋值表达式"></a>1. 赋值表达式</h2><p>规范中规定了三种形式的赋值表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AssignmentExpression : </span><br><span class="line">ConditionalExpression</span><br><span class="line">LeftHandSideExpression = AssignmentExpression </span><br><span class="line">LeftHandSideExpression AssignmentOperator AssignmentExpression</span><br></pre></td></tr></table></figure></p><p><code>a.x = a = a.y = {n: 2};</code> 是其中的第二种形式 (第三种形式中的<strong>AssignmentOperator</strong>在规范中是复合赋值符号，即 <code>+=</code> 等等)。 有的同学说，js中<code>=</code>是从右向左执行的。对于语句的执行，规范中写道: </p><blockquote><p>The source text of an ECMAScript program is first converted into a sequence of input elements, which are tokens, line terminators, comments, or white space. The source text is scanned from left to right, repeatedly taking the longest possible sequence of characters as the next input element.</p></blockquote><p>也就是说，源代码被转换为一系列的输入单元(输入单元的类型包括token，行结束符，注释和空白符); 然后从左到右进行解析，重复以最长子序列作为下一个输入单元。除此之外，规范规定了每种类型语句的执行流程，却并没有地方提到 <code>=</code> 要从右向左执行。造成这种广泛的误解的，可能是类似 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">MDN</a> 在语句优先级的地方提到了 <code>=</code> 的<em>Associativity</em>是从右到左，但其实这个<em>Associativity</em>并不是执行流程。</p><p>规范中规定了表达式  <strong>AssignmentExpression : LeftHandSideExpression = AssignmentExpression</strong> 的执行流程(11.13.1节中)，我们把这个流程命名为 parseAssignment, 后面会以 parseAssignment(n)来指代执行这里的第n步:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The production AssignmentExpression : LeftHandSideExpression = AssignmentExpression is evaluated as follows:</span><br><span class="line">1. Let lref be the result of evaluating LeftHandSideExpression.</span><br><span class="line">2. Let rref be the result of evaluating AssignmentExpression.</span><br><span class="line">3. Let rval be GetValue(rref).</span><br><span class="line">4. Throw a SyntaxError exception if the following conditions are all true:</span><br><span class="line">  Type(lref) is Reference is true</span><br><span class="line">  IsStrictReference(lref) is true</span><br><span class="line">  Type(GetBase(lref)) is Environment Record</span><br><span class="line">  GetReferencedName(lref) is either &quot;eval&quot; or &quot;arguments&quot;</span><br><span class="line">5. Call PutValue(lref, rval).</span><br><span class="line">6. Return rval.</span><br></pre></td></tr></table></figure></p><p>显然，第一步是 <code>evaluating LeftHandSideExpression</code> ，将结果赋给变量 <code>lref</code> 。然后是 <code>evaluating AssignmentExpression</code>， 将结果付给 <code>rref</code>。那么在表达式 <code>a.x = a = a.y = {n: 2}</code> 中 哪一部分是 <code>LeftHandSideExpression</code>, 哪一部分是 <code>rref</code> 有没有疑问呢？会不会<br><code>a.x = a</code> 或者 <code>a.x = a = a.y</code> 是 <code>LeftHandSideExpression</code> 呢？</p><p>再来看 <code>LeftHandSideExpression</code> 的语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LeftHandSideExpression : </span><br><span class="line">NewExpression </span><br><span class="line">CallExpression</span><br></pre></td></tr></table></figure></p><p>只有这两种形式，它们具体的语法定义我们就不翻了，不然可能会翻出10多层(事实上，规范中正是通过这种嵌套的表达式语法定义，规定了其优先级)。总之没有赋值表达式，并没有涉及到 <code>=</code> 语法。</p><p>且规范中规定了<em>语句解析顺序</em>是从左到右(Chapter 7)，所以 <code>a.x = a = a.y = {n: 2};</code> 中的 LeftHandSideExpression 就是 <code>a.x</code> 。</p><p>再仔细思考 <code>AssignmentExpression : LeftHandSideExpression = AssignmentExpression</code>， 把最后的 <code>AssignmentExpression</code>置换为左边的 <code>AssignmentExpression</code>，就得到了我们使用的这个表达式 : <code>AssignmentExpression : LeftHandSideExpression = (LeftHandSideExpression = AssignmentExpression)</code>。从这里我们也能看出，对于<code>a.x = a = a.y = {n: 2};</code>的执行来说，是<strong>先把 <code>a.x</code> 当作 <code>LeftHandSideExpression</code>，把<code>a = a.y = {n: 2}</code>当作 <code>AssignmentExpression</code>；执行到 <code>evaluating AssignmentExpression</code>时，再把 <code>a</code> 当作 <code>LeftHandSideExpression</code>， <code>a.y = {n: 2}</code>作为 <code>AssignmentExpression</code>。直到最后以 <code>a.y</code> 作为 <code>LeftHandSideExpression</code>， 以 <code>{n: 2}</code>作为<code>AssignmentExpression</code>(<code>AssignmentExpression</code>的第一种形式<code>ConditionalExpression</code>是允许为 对象字面量 的)。</strong></p><p>按照这样的执行步骤，第一步就是把 执行 <code>a.x</code> 的结果赋给 <code>lref</code>，<code>a.x</code>是一个 属性读取表达式，我们再来看它的执行流程。</p><pre><code>【Note】规范中并没有对优先级进行规定，只是通过设置语句的解析规则，形成了事实上的优先级。读者可以试试这段代码的结果:    var a = &quot;a&quot;    console.log(a) // &apos;a&apos;    true ? a : a = &apos;c&apos;    console.log(a) // &apos;a&apos;    false ? a : a = &quot;c&quot;    console.log(a) // &apos;c&apos;若按照优先级规定，条件表达式的优先级高于赋值表达式；那么语句应该按照 先执行条件表达式，后执行赋值表达式的顺序执行，第二个输出就应该是&apos;c&apos;了。但事实上是&apos;a&apos;。这是因为按照规范的表达式解析规则，=的左边总是被解析为 LeftHandSideExpression，而条件表达式并不在它的语法形式之中。所以按照最大可解析长度的原则，上式被解析为了true ? a : (a = &apos;c&apos;)，所以只有在最后 a 才会被改写为&apos;c&apos;。</code></pre><h2 id="2-属性获取表达式"><a href="#2-属性获取表达式" class="headerlink" title="2. 属性获取表达式"></a>2. 属性获取表达式</h2><p>规范中在 <code>LeftHandSideExpression</code> 相关 <code>Property Accessors</code>(11.2.1节) 中规定了其执行流程，我们把这个流程命名为 parseMember, 后面会以 parseMember(n)来指代执行这里的第n步:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:</span><br><span class="line">1. Let baseReference be the result of evaluating MemberExpression.</span><br><span class="line">2. Let baseValue be GetValue(baseReference).</span><br><span class="line">3. Let propertyNameReference be the result of evaluating Expression.</span><br><span class="line">4. Let propertyNameValue be GetValue(propertyNameReference).</span><br><span class="line">5. Call CheckObjectCoercible(baseValue).</span><br><span class="line">6. Let propertyNameString be ToString(propertyNameValue).</span><br><span class="line">7. If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let</span><br><span class="line">strict be false.</span><br><span class="line">8. Return a value of type Reference whose base value is baseValue and whose referenced name is</span><br><span class="line">propertyNameString, and whose strict mode flag is strict.</span><br></pre></td></tr></table></figure></p><p>我们看到这个流程大概是，从 <code>MemberExpression</code> (即这里的 <code>a</code>) 得到<code>baseValue</code>, 从 <code>Expression</code> (即这里的字符串 <code>x</code> )得到 <code>propertyNameString</code>，然后返回以它们组成的 <code>Reference</code>。<br>我们先去了解下 <code>Reference</code> 。</p><h2 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3. Reference"></a>3. Reference</h2><p>规范的第8章 <code>Types</code> 中, 将类型分为两大类: 一是<em>语言类型</em>，也就是提供给开发者的<code>Undefined, Null, Boolean, String, Number, and Object</code>；另一类是 <em>规范类型</em>，它们不会提供给开发者，也不一定对应到一个es实现中的数据结构，只是用来描述规范中的算法和刚才提到的<em>语言类型</em>，可以理解为是用来描述算法和数据结构的抽象。<code>Reference</code> 就是<em>规范类型</em>的一种。</p><p>规范的8.7节中这样写到: </p><blockquote><p>A Reference is a resolved name binding. A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.</p></blockquote><p>意即，<code>Reference</code> 是一个 <strong>已解析的命名绑定</strong>。所谓<strong>命名绑定</strong>，就是说它用来用一个<strong>命名</strong>找到对应的某个内部数值/数据；所谓<strong>已解析</strong>，就是说这个 命名 到 数据 的绑定关系是确定的。好比我们在面对函数中的某个变量，想要知道它的确切值是多少，就是想确定它的命名绑定。<br>简而言之，<code>Reference</code> 就是一个表示<em>引用类型</em>或者<em>环境对象</em>的抽象。一个 <code>Reference</code> 由三个部分组成: <code>base</code>  、 <code>reference name</code> 、 <code>strict flag</code>。</p><p><code>base</code>可以看作是就是引用的实体或作宿主，好比 <code>a.x</code> 就是一个引用，它的 <code>base value</code>就是 <code>a</code>；<code>reference name</code> 则是字符串 <code>x</code>。而在如下函数<code>func</code>中:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>a</code> 也是一个引用，它的 <code>base</code> 是 <code>func</code> 函数对应的执行环境的环境记录(<code>Enviroment Record</code>); <code>reference name</code>则是字符串 <code>&#39;a&#39;</code>。</p><p>前述表达式的执行流程中还用到了 <code>Reference</code> 的 <code>GetValue</code> 方法。我们看它的执行过程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GetValue (V)</span><br><span class="line">1. If Type(V) is not Reference, return V.</span><br><span class="line">2. Let base be the result of calling GetBase(V). // 获取 Reference 的 base component</span><br><span class="line">3. If IsUnresolvableReference(V), throw a ReferenceError exception.</span><br><span class="line">4. If IsPropertyReference(V), then</span><br><span class="line">a. If HasPrimitiveBase(V) is false, then let get be the [[Get]] internal method of base, otherwise let get be the special [[Get]] internal method defined below.</span><br><span class="line">b. Return the result of calling the get internal method using base as its this value, and passing GetReferencedName(V) for the argument.</span><br><span class="line">5. Else, base must be an environment record.</span><br><span class="line">a. Return the result of calling the GetBindingValue (see 10.2.1) concrete method of base passing</span><br><span class="line">GetReferencedName(V) and IsStrictReference(V) as arguments.</span><br></pre></td></tr></table></figure></p><p>即，如果参数 <code>V</code> 不是一个 <code>Reference</code> 类型，那么直接返回；否则在 <code>base</code>上取出对应 <code>reference name</code>的值并返回。</p><h2 id="4-题目分析"><a href="#4-题目分析" class="headerlink" title="4. 题目分析"></a>4. 题目分析</h2><p>有了这些基础，我们可以来分析面试题中的表达式了。步骤如下: </p><ol><li><p>执行parseAssignment(1), 即执行 <code>a.x</code> 表达式，将得到的 <code>Reference</code> 类型值赋给 <code>lref</code>。<code>a.x</code> 是一个 <code>Property Accessor</code>，我们来按照规范解析它的执行:</p><pre><code>1.1 parseMember(1). MemberExpression 是 a。这是表达式 PrimaryExpression 的 Identifier 类型，它会返回一个 Reference 类型的值: base 是全局环境变量(global enviroment record)，reference name是&apos;a&apos;，strict flag是false。 1.2 parseMember(2). 对全局环境变量调用 GetBindingValue(&apos;a&apos;)方法，在变量对象中找到对应的值，即 a 所引用的 对象字面量 {n: 1}。1.3 parseMember(3). Let propertyNameReference  = &apos;x&apos;1.4 parseMember(4). Let propertyNameValue = &apos;x&apos;1.5 parseMember(5). 检查是否可以1.2中的返回值是否可以转为 Object, {n: 1}本就是对象类型，返回true1.6 parseMember(6). 获取property name string，即&apos;x&apos;1.7 parseMember(7). 设置 strict flag 为false1.8 parseMember(8). 返回一个 Reference 类型的值，base 是 {n: 1}, reference name是&apos;x&apos;， strict flag 是 false。</code></pre><p> 这里第一步执行完得到的 lref 就是1.8中返回的值。</p></li><li><p>parseAssignment(2). 执行 a = a.y = {n: 2}，将返回值赋给 rref。它的执行如下: </p><pre><code>2.1 执行 a。它返回一个 Reference 类型的值，base 是 全局环境变量，refrence name是&apos;a&apos;, strict flag是false。我们姑且称这一步的lref为 lref2.1。2.2 执行 a.y = {n: 2}。它也是一个赋值表达式，执行如下:    2.2.1 执行 a.y 。这里又涉及到了对 a 的解析，前面的操作并没有改变 a 的引用，所以到现在为止，a 仍然会被解析为全局环境变量上的一个命名绑定。所以对 a.y 的解析所返回的 Reference 中，base 组件是就是lref中的base。 我们姑且称这一步的lref为 lref2.2.1，它的组成: base 是 {n: 1}，refrence name是&apos;y&apos;, strict flag是false。(注意 lref2.2.1 的 base 与 lref 的 base， 是同一个对象。因为 a 都会解析为 全局环境变量 上对应属性&apos;a&apos;的对象。)    2.2.2 parseAssignment(2). 这里右边是一个 对象初始化表达式，返回一个对象类型的值 {n: 2}。    2.2.3 parseAssignment(3). 对上一步中的返回值执行 GetValue(rref)，结果仍然是 {n: 2}, 赋给 rval2.2.3。    2.2.4 parseAssignment(4). 判断是否抛异常，这里不会。    2.2.5 parseAssignment(5). 调用 PutValue(lref2.2.1, rval2.2.3)，结果是lref2.2.1 的base增加了一个属性，此时变为了 {n: 1, y: {n: 2}} // 这里的 base 与 lref 中的 base 仍然是同一个对象    2.2.6 parseAssignment(6). 返回 rval2.2.3。所以这一步返回 rval2.2.3。2.3 parseAssignment(3). 对2.2返回的值进行 GetValue(rref), 仍然是 rval2.2.32.4 parseAssignment(4). 判断是否要抛异常，这里不会。2.5 parseAssignment(5). 调用 PutValue(lref2.1, rval2.2.3)，lref2.1 的base是 全局环境变量，这里修改了其中变量 a 的引用，指向新的对象 rval2.2.32.6 parseAssignment(6). 返回 rval2.2.3。</code></pre><p> 这一步的返回仍然是对象 rval2.2.3。</p></li><li>parseAssignment(3). 将 rval 设为上一步的返回即 rval2.2.3。</li><li>parseAssignment(4). 判断是否要抛异常，这里不会。</li><li>parseAssignment(5). 调用 PutValue(lref, rval)，lref 的base 增加了一个属性，此时变为了 {n: 1, y: {n: 2}, x: {n: 2}}</li><li>Return rval.</li></ol><p>所以执行完后，变量 a 所引用的对象是 {n: 2}。 而它之前指向的对象，也即这时变量<code>b</code>指向的对象(<code>b</code> 的指向未改变过)，变为了 <code>{n: 1, y: {n: 2}, x: {n: 2}}</code>。可以用 JSON.stringify 验证下b。而且这时候 <code>b.x</code> 、<code>b.y</code> 和 a 指向同一个对象。 </p><p>其实这里的关键点就是，赋值表达式要先对左边的表达进行引用确定，再进行赋值。</p><p>PS: 文中对于符号优先级的阐述，完全出于自己对规范的理解，欢迎指正</p><p>PPS: 经社区同学指出，贴出文章所参照的规范地址<a href="http://www.ecma-international.org/ecma-262/5.1/index.html" target="_blank" rel="noopener">EcmaScript 5.1 Edition</a>。文章参照的是旧版本，es6之后对于这个问题的分析是一致的，差异主要是:</p><ul><li>表达式增加了更多语法。比如es6中赋值表达式增加了对箭头函数和Yeild语法的支持。</li><li>对应的章节不同。比如es6中表达式放到了第12章，对Reference的阐述放在了6.2.3(The Reference Specification Type )，关于输入源码解析的机制放在了第11章(ECMAScript Language: Lexical Grammar)中。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从一道常见的面试题开始:&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
