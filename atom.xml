<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>mg20</title>
  
  <subtitle>知行合一</subtitle>
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://ginobilee.github.io/"/>
  <updated>2019-01-28T01:12:42.000Z</updated>
  <id>https://ginobilee.github.io/</id>
  
  <author>
    <name>mg20</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>fetch返回一个promise，所以它在收到响应时直接进入微任务队列么？</title>
    <link href="https://ginobilee.github.io/2019/01/28/xhr%20vs%20fetch/"/>
    <id>https://ginobilee.github.io/2019/01/28/xhr vs fetch/</id>
    <published>2019-01-28T01:17:41.000Z</published>
    <updated>2019-01-28T01:12:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>文章起源于 XHR(XMLHttpRequest) 与 Fetch 的比较。Fetch 的重大改变之一就是它返回一个 Promise，而在 XHR 中是利用回调的方式进行响应。XHR 响应后，会将对应的回调推入对应于网络请求的task(是一个macro task)中。而 Fetch 返回一个promise，浏览器会把 promise 的回调放入微任务中，那么是不是 Fetch 的响应也会更早的执行呢？   </p><h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>为了验证 Fetch 的回调是不是直接放入微任务中，我设计了这样一个实验：同时用fetch发出两个相同的请求，在其回调中，利用while循环阻塞一定时间，之后再直接resolve一个promise。如果fetch的回调直接放入微任务中，在前一个请求的响应被阻塞的时候，后一个响应应该也触发了，那么后一个响应的回调会直接进入微任务队列中，从而早于在前一个fetch回调中新resolve的promise被执行。结果是不是这样呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = fetch(<span class="string">"http://baike.baidu.com/api/openapi/BaikeLemmaCardApi?scope=103&amp;format=json&amp;appid=379020&amp;bk_key=shoe&amp;bk_length=60"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = fetch(<span class="string">"http://baike.baidu.com/api/openapi/BaikeLemmaCardApi?scope=103&amp;format=json&amp;appid=379020&amp;bk_key=shoe&amp;bk_length=60"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span></span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="comment">// wait for 3 s</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p1 callback, before wait, and now is : "</span>, start)</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() &lt; start + <span class="number">5</span> * <span class="number">1000</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p1 callback, after wait, and now is : "</span>, start)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise initiated in p1 fire"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="comment">// wait for 3 s</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p2 callback, before wait, and now is : "</span>, start)</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() &lt; start + <span class="number">5</span> * <span class="number">1000</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p2 callback, after wait, and now is : "</span>, start)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise initiated in p2 fire"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// in p2 callback, before wait, and now is :  1548601804877</span></span><br><span class="line"><span class="comment">// in p2 callback, after wait, and now is :  1548601804877</span></span><br><span class="line"><span class="comment">// promise initiated in p2 fire</span></span><br><span class="line"><span class="comment">// in p1 callback, before wait, and now is :  1548601809880</span></span><br><span class="line"><span class="comment">// in p1 callback, after wait, and now is :  1548601809880</span></span><br><span class="line"><span class="comment">// promise initiated in p1 fire</span></span><br></pre></td></tr></table></figure></p><p>显然，输出并非如此，在首先响应的fetch的回调中，触发的promise仍然早于另外一个fetch的回调被调用了。<br>这样的结果显然跟 XHR 没有区别。那么是不是两个请求的响应时间差超过了3s呢？尝试加大<code>while</code>循环的时延后，仍然不行。</p><h3 id="模拟一个单纯的promise的fetch"><a href="#模拟一个单纯的promise的fetch" class="headerlink" title="模拟一个单纯的promise的fetch"></a>模拟一个单纯的promise的fetch</h3><p>索性来模拟一个按照上述思路触发的fetch:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟一个 纯 promise 的 fetch</span></span><br><span class="line"><span class="keyword">let</span> r = []</span><br><span class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="keyword">function</span>(<span class="params">uri, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resovle, reject</span>) </span>&#123;</span><br><span class="line">    r.push(resovle)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f1 = fetch(<span class="string">"x"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise f1 fire: "</span>, res)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="string">"f1"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f1"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> f2 = fetch(<span class="string">"y"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise f2 fire: "</span>, res)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="string">"f2"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f2"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// after 100ms, f1 and f2 fires. note here they are fired in the 'same tick'</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  r.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">    fn(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// promise f1 fire:  1</span></span><br><span class="line"><span class="comment">// promise f2 fire:  1</span></span><br><span class="line"><span class="comment">// f1</span></span><br><span class="line"><span class="comment">// f2</span></span><br></pre></td></tr></table></figure></p><p>在这段代码中，我以一种纯粹promise的方式模拟fetch的行为。这样两个fetch在100ms后被同时resolve，于是先后进入微任务队列；而在首先执行的回调中触发的promise，确实会晚于另一个fetch的回调执行。   </p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>到这里足可看出，fetch绝不是如模拟代码中的一个单纯的promise。关键在于，fetch会发起一个网络请求，当请求被响应时，怎么通知主线程来处理回调? 在 XHR 中，是将回调放入对应于网络请求的任务队列中，fetch是否也是这样呢？<br>查找 WHATWG 的对应规范，其中确实提到收到响应后，会在网络请求的任务队列中推入任务:   </p><blockquote><p>Queue a task to run an operation on request’s client’s responsible event loop using the networking task source.</p></blockquote><p>即将task推入对应的event loop的网络请求任务队列中。至此可以认为，fetch的工作模式实际上是:</p><ol><li>请求被响应，在网络请求任务队列中推入一个任务。这个任务应该是执行 enqueue promise的操作(虽然规范中并没有提到)</li><li>主线程的event loop执行到网络请求任务队列的该任务时，把对应promise的回调推入微任务</li><li>主线程的event loop在执行到当前循环的微任务检查点时执行该promise的响应</li></ol><p>如此，说明从event loop的执行流程上，xhr 与 fetch的差别其实不大。两者都会首先通过网络请求的宏任务来触发。</p><hr><h3 id="搞清楚这个问题有什么用？"><a href="#搞清楚这个问题有什么用？" class="headerlink" title="搞清楚这个问题有什么用？"></a>搞清楚这个问题有什么用？</h3><p>在使用 xhr 时，在其回调中利用 promise 将任务放入微任务队列中，这个微任务一定会早于其它触发的 xhr 执行；如果对 fetch 上述模型不了解，会去想是否 fetch 中新触发的 promise 会晚于其它并发收到 fetch 的响应？在对处理顺序有要求的场合，这里就会影响到是否可以在回调中使用 promise 进行异步处理。搞清楚多个 fetch 的回调仍然会走 event loop 的多个loop，就明白是否会对程序的执行流产生影响。   </p><hr><p>ref:   </p><ol><li><a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noopener">Fetch Living Standard</a>   </li><li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">event loop in HTML</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;文章起源于 XHR(XMLHttpRequest) 与 Fetch 的比较。Fetch 的重大改变之一就是它返回一个 Promise，而在 XHR 中是利用回调的方式进行响应。XHR 响应后，会将对应的回调推入对应于网络请求的task(是一个macro task)中。而 F
      
    
    </summary>
    
    
      <category term="fetch promise" scheme="https://ginobilee.github.io/tags/fetch-promise/"/>
    
  </entry>
  
  <entry>
    <title>我欲建立的知识结构模型</title>
    <link href="https://ginobilee.github.io/2019/01/25/%E6%88%91%E6%AC%B2%E5%BB%BA%E7%AB%8B%E7%9A%84%E7%9F%A5%E8%AF%86%E7%BB%93%E6%9E%84%E6%A8%A1%E5%9E%8B/"/>
    <id>https://ginobilee.github.io/2019/01/25/我欲建立的知识结构模型/</id>
    <published>2019-01-25T07:38:19.000Z</published>
    <updated>2019-01-25T09:42:57.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="起源及程序员的一般知识结构"><a href="#起源及程序员的一般知识结构" class="headerlink" title="起源及程序员的一般知识结构"></a>起源及程序员的一般知识结构</h2><p>在跟踪winter的《重学前端》系列时的所想。  </p><p>winter提到，要建立自己的知识架构。这刚好是我最近在思考的问题。  </p><p>一个前端，首先是一个程序员。程序员的基本知识架构，前端也是应该具备的，比如数据结构、算法、编译原理、操作系统等等。但这些更是一个人的能力素质基础，虽然决定了一个人在技术上能够达到的高度，却不一定能在工作中立即解决面对的问题。这些素质我想可以认为是一个前端(以及程序员)在”道”这个层次的要求。而前端作为一个工程实践性远高于理论探索性的职业，从业者和招聘者也自然会忽视这方面的要求，而对具体的职业技能更为看重。  </p><p>大佬也提到这门课不会关注前面说的计算机基础，而是重点关注前端领域内的技能。我认为，在前端领域内，也可以划分为基础素质或曰能力，以及实践技能。基础素质按照大佬的这个划分已经是极好的了。javascript/html/css可以认为是前端从业者的工具，浏览器/node.js这些是前端工作的宿主，工程化是前端从业者利用工具在宿主上实现特定工程目标这一个过程的经验总结。这些可以认为是一个前端在”法”这个层次的要求。  </p><p>按照道、法、术的层次，现在社区中充斥的，”xx天带你撸一个xx”之类的文章或视频，基本上都是”术”这个层次。法与术，不同的人会有不同的见解。对于a来说认为是法的东西，可能对于b来说只是术，对于c来说已经是道了。我想这也能反映出一个人的认知水平。  </p><h2 id="javascript的知识结构"><a href="#javascript的知识结构" class="headerlink" title="javascript的知识结构"></a>javascript的知识结构</h2><p>具体到javascript这一块，我之前的认知将其从结构上分为这么两块: 语法+运行时。我所划分的语法就是指es规范，其实是大佬所讲的一整个javascript这块。而运行时是规范中implementation的概念，是浏览器(html标准)/node.js中对于规范的实现，以及这些特定实现中交织的其它(非es规范)部分。举例来说，大家经常提到的eventloop，其实是html或node.js中的机制，两者分别有对应的规范/实现。而在es规范中，其实只是在es6加入模块化和Promise之后才有相关的概念Job。而对于html规范中的eventloop，js的运行(脚本执行/多个JobQueue的执行)只是其中一部分，此外还有对于渲染的处理(resize/paint/requestAnimationFrame等等)。我觉得将这些概念区分清楚是大有裨益于自己知识结构的建立的，它们就像知识之间的边界，对于不同的知识有清晰的边界，才会有更清晰的认知。  </p><p>大佬将javascript的知识结构划分为 文法/语义/运行时 是一种更精准的划分。  </p><h2 id="我对于前端知识结构的认识"><a href="#我对于前端知识结构的认识" class="headerlink" title="我对于前端知识结构的认识"></a>我对于前端知识结构的认识</h2><p>我所认为的前端知识架构，其实从一个简单的问题就可以包括进来:一个页面从输入地址到可交互，有哪些过程？  </p><p>这个问题可以不停地深入下去，找到所有的细节；同时所有问题又都可以在这个问题上找到它的位置。比如从问题本身出发，牵涉到的问题就有:  </p><ol><li>网络。域名怎么转换为服务器地址?这里会不会有安全性问题？域名解析服务会不会挂掉(我们遇到过)?</li><li>http协议。一个请求的结构？缓存规则？service worker？动静分离？不同的状态码什么含义？跨域？动词方法？restful接口？预检请求？性能优化中相关措施？https？</li><li>浏览器的渲染过程。这是一个大的话题，里面信息量巨大。如何解析html？文档模型与渲染树？脚本的加载？如何优化脚本的加载？多个脚本加载有没有优化方法？为什么要以某种模式优化(比如script放在body后)？为什么处理js要阻塞渲染，浏览器为何如此设计，为何不像客户端一样分成两个线程？加载脚本的网络请求是同一个线程么？那多个脚本的加载是同一个线程么？脚本加载完后如何与渲染线程交互？把脚本放在html加载与放在另一个脚本里加载有区别么？js的模块化？要不要将多个请求分成多个域名，为什么？浏览器的事件循环模型？不同浏览器的兼容性？如何抹平差异？</li><li>页面的交互一般是通过js实现的，那么js的领域都可以牵涉进来了。<ol><li>js的语法和运行时</li><li>js可以访问到的宿主接口(这其实也是很大的一个范畴，比如setTimeout/setInterval都是其中的。而只是xhr/fetch就可以牵出许多问题。比如异步网络请求是在单独的线程执行的么？那么请求结果如何通知主线程？fetch请求会返回一个promise，那么它是放在Mircotask Queue的么？)</li><li>不同宿主对于js的实现？</li><li>es规范中的新语法？如何应用在没有提供实现的宿主中？<br>…</li></ol></li><li>内容结构和样式的组织: html与css。</li><li>站点结构。如何部署？如何最小更新？这里又牵涉到了工程化问题的一部分。<br>…</li></ol><p>回过头来，再将知识规划成上面这一个体系的话，可以将所有东西都划进对应的slot内。  </p><p>比如模块化，他应该是属于什么问题？它从一个工程问题而来(es规范最初没有模块化，只有社区的实践，require这样的语法在规范中是没有的)，演变成一个es规范的问题。而且我们可以看到，对于这个问题，es规范的解决是优于社区的解决方案的。规范的解决思路，是从语言的层面上去提供能力，社区的解决思路还是停留在解决问题。当然，规范的解决思路从社区中汲取了营养，这是毫无疑问的。   </p><p>总之，我想建立的知识体系，是对应这样一个流程的: 用这一个问题可以把所有这些概念包容进去；对于任何问题，又都可以在这个问题中找到它的坑位。   </p><h2 id="我想建立的知识结构"><a href="#我想建立的知识结构" class="headerlink" title="我想建立的知识结构"></a>我想建立的知识结构</h2><p>我想建立的是:  </p><ol><li>首先明白es规范对于问题是怎么阐述的。这里就包括 语法/算法。</li><li>各个宿主中是如何实现的。比如Promise，浏览器的实现？浏览器又是如何利用这些装置提供api的，比如fetch？</li><li>从第1个问题引申出的是js运行时的一个概览，明白从模块/函数到语句的运行过程；从第2个问题引申出的是浏览器或其它宿主是如何实现的？它们的内部架构？</li><li>明白了这两块，就基本明了了前端的基础。再辅以网络/更外层的宿主(浏览器可以认为是js宿主，操作系统可以认为是浏览器宿主，服务器可以认为是操作系统宿主)的原理，这个就是不断扩展边界的过程了。</li></ol><p>ref:    </p><ol><li><a href="https://time.geekbang.org/column/article/77749" target="_blank" rel="noopener">winter的分享之明确你的前端学习路线与方法</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;起源及程序员的一般知识结构&quot;&gt;&lt;a href=&quot;#起源及程序员的一般知识结构&quot; class=&quot;headerlink&quot; title=&quot;起源及程序员的一般知识结构&quot;&gt;&lt;/a&gt;起源及程序员的一般知识结构&lt;/h2&gt;&lt;p&gt;在跟踪winter的《重学前端》系列时的所想。  &lt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>从规范看赋值表达式的解析</title>
    <link href="https://ginobilee.github.io/2019/01/24/%E4%BB%8E%E8%A7%84%E8%8C%83%E7%9C%8B%E8%B5%8B%E5%80%BC%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%9A%84%E8%A7%A3%E6%9E%90/"/>
    <id>https://ginobilee.github.io/2019/01/24/从规范看赋值表达式的解析/</id>
    <published>2019-01-24T01:23:04.000Z</published>
    <updated>2019-01-24T07:04:42.000Z</updated>
    
    <content type="html"><![CDATA[<p>从一道常见的面试题开始:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;<span class="attr">n</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">a.x = a = a.y = &#123;<span class="attr">n</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(a.x);</span><br><span class="line"><span class="built_in">console</span>.log(b.y);</span><br></pre></td></tr></table></figure></p><p>显然，关键点在于最后一个语句的执行。这个语句的执行主要涉及了 <em>属性获取表达式</em> 和 <em>赋值表达式</em>，先去规范里看对于这两种语法及其执行的规定。</p><h2 id="1-赋值表达式"><a href="#1-赋值表达式" class="headerlink" title="1. 赋值表达式"></a>1. 赋值表达式</h2><p>规范中规定了三种形式的赋值表达式:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">AssignmentExpression : </span><br><span class="line">ConditionalExpression</span><br><span class="line">LeftHandSideExpression = AssignmentExpression </span><br><span class="line">LeftHandSideExpression AssignmentOperator AssignmentExpression</span><br></pre></td></tr></table></figure></p><p><code>a.x = a = a.y = {n: 2};</code> 是其中的第二种形式 (第三种形式中的<strong>AssignmentOperator</strong>在规范中是复合赋值符号，即 <code>+=</code> 等等)。 有的同学说，js中<code>=</code>是从右向左执行的。对于语句的执行，规范中写道: </p><blockquote><p>The source text of an ECMAScript program is first converted into a sequence of input elements, which are tokens, line terminators, comments, or white space. The source text is scanned from left to right, repeatedly taking the longest possible sequence of characters as the next input element.</p></blockquote><p>也就是说，源代码被转换为一系列的输入单元(输入单元的类型包括token，行结束符，注释和空白符); 然后从左到右进行解析，重复以最长子序列作为下一个输入单元。除此之外，规范规定了每种类型语句的执行流程，却并没有地方提到 <code>=</code> 要从右向左执行。造成这种广泛的误解的，可能是类似 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">MDN</a> 在语句优先级的地方提到了 <code>=</code> 的<em>Associativity</em>是从右到左，但其实这个<em>Associativity</em>并不是执行流程。</p><p>规范中规定了表达式  <strong>AssignmentExpression : LeftHandSideExpression = AssignmentExpression</strong> 的执行流程(11.13.1节中)，我们把这个流程命名为 parseAssignment, 后面会以 parseAssignment(n)来指代执行这里的第n步:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The production AssignmentExpression : LeftHandSideExpression = AssignmentExpression is evaluated as follows:</span><br><span class="line">1. Let lref be the result of evaluating LeftHandSideExpression.</span><br><span class="line">2. Let rref be the result of evaluating AssignmentExpression.</span><br><span class="line">3. Let rval be GetValue(rref).</span><br><span class="line">4. Throw a SyntaxError exception if the following conditions are all true:</span><br><span class="line">  Type(lref) is Reference is true</span><br><span class="line">  IsStrictReference(lref) is true</span><br><span class="line">  Type(GetBase(lref)) is Environment Record</span><br><span class="line">  GetReferencedName(lref) is either &quot;eval&quot; or &quot;arguments&quot;</span><br><span class="line">5. Call PutValue(lref, rval).</span><br><span class="line">6. Return rval.</span><br></pre></td></tr></table></figure></p><p>显然，第一步是 <code>evaluating LeftHandSideExpression</code> ，将结果赋给变量 <code>lref</code> 。然后是 <code>evaluating AssignmentExpression</code>， 将结果付给 <code>rref</code>。那么在表达式 <code>a.x = a = a.y = {n: 2}</code> 中 哪一部分是 <code>LeftHandSideExpression</code>, 哪一部分是 <code>rref</code> 有没有疑问呢？会不会<br><code>a.x = a</code> 或者 <code>a.x = a = a.y</code> 是 <code>LeftHandSideExpression</code> 呢？</p><p>再来看 <code>LeftHandSideExpression</code> 的语法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LeftHandSideExpression : </span><br><span class="line">NewExpression </span><br><span class="line">CallExpression</span><br></pre></td></tr></table></figure></p><p>只有这两种形式，它们具体的语法定义我们就不翻了，不然可能会翻出10多层(事实上，规范中正是通过这种嵌套的表达式语法定义，规定了其优先级)。总之没有赋值表达式，并没有涉及到 <code>=</code> 语法。</p><p>且规范中规定了<em>语句解析顺序</em>是从左到右(Chapter 7)，所以 <code>a.x = a = a.y = {n: 2};</code> 中的 LeftHandSideExpression 就是 <code>a.x</code> 。</p><p>再仔细思考 <code>AssignmentExpression : LeftHandSideExpression = AssignmentExpression</code>， 把最后的 <code>AssignmentExpression</code>置换为左边的 <code>AssignmentExpression</code>，就得到了我们使用的这个表达式 : <code>AssignmentExpression : LeftHandSideExpression = (LeftHandSideExpression = AssignmentExpression)</code>。从这里我们也能看出，对于<code>a.x = a = a.y = {n: 2};</code>的执行来说，是<strong>先把 <code>a.x</code> 当作 <code>LeftHandSideExpression</code>，把<code>a = a.y = {n: 2}</code>当作 <code>AssignmentExpression</code>；执行到 <code>evaluating AssignmentExpression</code>时，再把 <code>a</code> 当作 <code>LeftHandSideExpression</code>， <code>a.y = {n: 2}</code>作为 <code>AssignmentExpression</code>。直到最后以 <code>a.y</code> 作为 <code>LeftHandSideExpression</code>， 以 <code>{n: 2}</code>作为<code>AssignmentExpression</code>(<code>AssignmentExpression</code>的第一种形式<code>ConditionalExpression</code>是允许为 对象字面量 的)。</strong></p><p>按照这样的执行步骤，第一步就是把 执行 <code>a.x</code> 的结果赋给 <code>lref</code>，<code>a.x</code>是一个 属性读取表达式，我们再来看它的执行流程。</p><pre><code>【Note】规范中并没有对优先级进行规定，只是通过设置语句的解析规则，形成了事实上的优先级。读者可以试试这段代码的结果:    var a = &quot;a&quot;    console.log(a) // &apos;a&apos;    true ? a : a = &apos;c&apos;    console.log(a) // &apos;a&apos;    false ? a : a = &quot;c&quot;    console.log(a) // &apos;c&apos;若按照优先级规定，条件表达式的优先级高于赋值表达式；那么语句应该按照 先执行条件表达式，后执行赋值表达式的顺序执行，第二个输出就应该是&apos;c&apos;了。但事实上是&apos;a&apos;。这是因为按照规范的表达式解析规则，=的左边总是被解析为 LeftHandSideExpression，而条件表达式并不在它的语法形式之中。所以按照最大可解析长度的原则，上式被解析为了true ? a : (a = &apos;c&apos;)，所以只有在最后 a 才会被改写为&apos;c&apos;。</code></pre><h2 id="2-属性获取表达式"><a href="#2-属性获取表达式" class="headerlink" title="2. 属性获取表达式"></a>2. 属性获取表达式</h2><p>规范中在 <code>LeftHandSideExpression</code> 相关 <code>Property Accessors</code>(11.2.1节) 中规定了其执行流程，我们把这个流程命名为 parseMember, 后面会以 parseMember(n)来指代执行这里的第n步:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">The production MemberExpression : MemberExpression [ Expression ] is evaluated as follows:</span><br><span class="line">1. Let baseReference be the result of evaluating MemberExpression.</span><br><span class="line">2. Let baseValue be GetValue(baseReference).</span><br><span class="line">3. Let propertyNameReference be the result of evaluating Expression.</span><br><span class="line">4. Let propertyNameValue be GetValue(propertyNameReference).</span><br><span class="line">5. Call CheckObjectCoercible(baseValue).</span><br><span class="line">6. Let propertyNameString be ToString(propertyNameValue).</span><br><span class="line">7. If the syntactic production that is being evaluated is contained in strict mode code, let strict be true, else let</span><br><span class="line">strict be false.</span><br><span class="line">8. Return a value of type Reference whose base value is baseValue and whose referenced name is</span><br><span class="line">propertyNameString, and whose strict mode flag is strict.</span><br></pre></td></tr></table></figure></p><p>我们看到这个流程大概是，从 <code>MemberExpression</code> (即这里的 <code>a</code>) 得到<code>baseValue</code>, 从 <code>Expression</code> (即这里的字符串 <code>x</code> )得到 <code>propertyNameString</code>，然后返回以它们组成的 <code>Reference</code>。<br>我们先去了解下 <code>Reference</code> 。</p><h2 id="3-Reference"><a href="#3-Reference" class="headerlink" title="3. Reference"></a>3. Reference</h2><p>规范的第8章 <code>Types</code> 中, 将类型分为两大类: 一是<em>语言类型</em>，也就是提供给开发者的<code>Undefined, Null, Boolean, String, Number, and Object</code>；另一类是 <em>规范类型</em>，它们不会提供给开发者，也不一定对应到一个es实现中的数据结构，只是用来描述规范中的算法和刚才提到的<em>语言类型</em>，可以理解为是用来描述算法和数据结构的抽象。<code>Reference</code> 就是<em>规范类型</em>的一种。</p><p>规范的8.7节中这样写到: </p><blockquote><p>A Reference is a resolved name binding. A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag. The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record (10.2.1). A base value of undefined indicates that the reference could not be resolved to a binding. The referenced name is a String.</p></blockquote><p>意即，<code>Reference</code> 是一个 <strong>已解析的命名绑定</strong>。所谓<strong>命名绑定</strong>，就是说它用来用一个<strong>命名</strong>找到对应的某个内部数值/数据；所谓<strong>已解析</strong>，就是说这个 命名 到 数据 的绑定关系是确定的。好比我们在面对函数中的某个变量，想要知道它的确切值是多少，就是想确定它的命名绑定。<br>简而言之，<code>Reference</code> 就是一个表示<em>引用类型</em>或者<em>环境对象</em>的抽象。一个 <code>Reference</code> 由三个部分组成: <code>base</code>  、 <code>reference name</code> 、 <code>strict flag</code>。</p><p><code>base</code>可以看作是就是引用的实体或作宿主，好比 <code>a.x</code> 就是一个引用，它的 <code>base value</code>就是 <code>a</code>；<code>reference name</code> 则是字符串 <code>x</code>。而在如下函数<code>func</code>中:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="string">'a'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><code>a</code> 也是一个引用，它的 <code>base</code> 是 <code>func</code> 函数对应的执行环境的环境记录(<code>Enviroment Record</code>); <code>reference name</code>则是字符串 <code>&#39;a&#39;</code>。</p><p>前述表达式的执行流程中还用到了 <code>Reference</code> 的 <code>GetValue</code> 方法。我们看它的执行过程:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">GetValue (V)</span><br><span class="line">1. If Type(V) is not Reference, return V.</span><br><span class="line">2. Let base be the result of calling GetBase(V). // 获取 Reference 的 base component</span><br><span class="line">3. If IsUnresolvableReference(V), throw a ReferenceError exception.</span><br><span class="line">4. If IsPropertyReference(V), then</span><br><span class="line">a. If HasPrimitiveBase(V) is false, then let get be the [[Get]] internal method of base, otherwise let get be the special [[Get]] internal method defined below.</span><br><span class="line">b. Return the result of calling the get internal method using base as its this value, and passing GetReferencedName(V) for the argument.</span><br><span class="line">5. Else, base must be an environment record.</span><br><span class="line">a. Return the result of calling the GetBindingValue (see 10.2.1) concrete method of base passing</span><br><span class="line">GetReferencedName(V) and IsStrictReference(V) as arguments.</span><br></pre></td></tr></table></figure></p><p>即，如果参数 <code>V</code> 不是一个 <code>Reference</code> 类型，那么直接返回；否则在 <code>base</code>上取出对应 <code>reference name</code>的值并返回。</p><h2 id="4-题目分析"><a href="#4-题目分析" class="headerlink" title="4. 题目分析"></a>4. 题目分析</h2><p>有了这些基础，我们可以来分析面试题中的表达式了。步骤如下: </p><ol><li><p>执行parseAssignment(1), 即执行 <code>a.x</code> 表达式，将得到的 <code>Reference</code> 类型值赋给 <code>lref</code>。<code>a.x</code> 是一个 <code>Property Accessor</code>，我们来按照规范解析它的执行:</p><pre><code>1.1 parseMember(1). MemberExpression 是 a。这是表达式 PrimaryExpression 的 Identifier 类型，它会返回一个 Reference 类型的值: base 是全局环境变量(global enviroment record)，reference name是&apos;a&apos;，strict flag是false。 1.2 parseMember(2). 对全局环境变量调用 GetBindingValue(&apos;a&apos;)方法，在变量对象中找到对应的值，即 a 所引用的 对象字面量 {n: 1}。1.3 parseMember(3). Let propertyNameReference  = &apos;x&apos;1.4 parseMember(4). Let propertyNameValue = &apos;x&apos;1.5 parseMember(5). 检查是否可以1.2中的返回值是否可以转为 Object, {n: 1}本就是对象类型，返回true1.6 parseMember(6). 获取property name string，即&apos;x&apos;1.7 parseMember(7). 设置 strict flag 为false1.8 parseMember(8). 返回一个 Reference 类型的值，base 是 {n: 1}, reference name是&apos;x&apos;， strict flag 是 false。</code></pre><p> 这里第一步执行完得到的 lref 就是1.8中返回的值。</p></li><li><p>parseAssignment(2). 执行 a = a.y = {n: 2}，将返回值赋给 rref。它的执行如下: </p><pre><code>2.1 执行 a。它返回一个 Reference 类型的值，base 是 全局环境变量，refrence name是&apos;a&apos;, strict flag是false。我们姑且称这一步的lref为 lref2.1。2.2 执行 a.y = {n: 2}。它也是一个赋值表达式，执行如下:    2.2.1 执行 a.y 。这里又涉及到了对 a 的解析，前面的操作并没有改变 a 的引用，所以到现在为止，a 仍然会被解析为全局环境变量上的一个命名绑定。所以对 a.y 的解析所返回的 Reference 中，base 组件是就是lref中的base。 我们姑且称这一步的lref为 lref2.2.1，它的组成: base 是 {n: 1}，refrence name是&apos;y&apos;, strict flag是false。(注意 lref2.2.1 的 base 与 lref 的 base， 是同一个对象。因为 a 都会解析为 全局环境变量 上对应属性&apos;a&apos;的对象。)    2.2.2 parseAssignment(2). 这里右边是一个 对象初始化表达式，返回一个对象类型的值 {n: 2}。    2.2.3 parseAssignment(3). 对上一步中的返回值执行 GetValue(rref)，结果仍然是 {n: 2}, 赋给 rval2.2.3。    2.2.4 parseAssignment(4). 判断是否抛异常，这里不会。    2.2.5 parseAssignment(5). 调用 PutValue(lref2.2.1, rval2.2.3)，结果是lref2.2.1 的base增加了一个属性，此时变为了 {n: 1, y: {n: 2}} // 这里的 base 与 lref 中的 base 仍然是同一个对象    2.2.6 parseAssignment(6). 返回 rval2.2.3。所以这一步返回 rval2.2.3。2.3 parseAssignment(3). 对2.2返回的值进行 GetValue(rref), 仍然是 rval2.2.32.4 parseAssignment(4). 判断是否要抛异常，这里不会。2.5 parseAssignment(5). 调用 PutValue(lref2.1, rval2.2.3)，lref2.1 的base是 全局环境变量，这里修改了其中变量 a 的引用，指向新的对象 rval2.2.32.6 parseAssignment(6). 返回 rval2.2.3。</code></pre><p> 这一步的返回仍然是对象 rval2.2.3。</p></li><li>parseAssignment(3). 将 rval 设为上一步的返回即 rval2.2.3。</li><li>parseAssignment(4). 判断是否要抛异常，这里不会。</li><li>parseAssignment(5). 调用 PutValue(lref, rval)，lref 的base 增加了一个属性，此时变为了 {n: 1, y: {n: 2}, x: {n: 2}}</li><li>Return rval.</li></ol><p>所以执行完后，变量 a 所引用的对象是 {n: 2}。 而它之前指向的对象，也即这时变量<code>b</code>指向的对象(<code>b</code> 的指向未改变过)，变为了 <code>{n: 1, y: {n: 2}, x: {n: 2}}</code>。可以用 JSON.stringify 验证下b。而且这时候 <code>b.x</code> 、<code>b.y</code> 和 a 指向同一个对象。 </p><p>其实这里的关键点就是，赋值表达式要先对左边的表达进行引用确定，再进行赋值。</p><p>PS: 文中对于符号优先级的阐述，完全出于自己对规范的理解，欢迎指正</p><p>PPS: 经社区同学指出，贴出文章所参照的规范地址<a href="http://www.ecma-international.org/ecma-262/5.1/index.html" target="_blank" rel="noopener">EcmaScript 5.1 Edition</a>。文章参照的是旧版本，es6之后对于这个问题的分析是一致的，差异主要是:</p><ul><li>表达式增加了更多语法。比如es6中赋值表达式增加了对箭头函数和Yeild语法的支持。</li><li>对应的章节不同。比如es6中表达式放到了第12章，对Reference的阐述放在了6.2.3(The Reference Specification Type )，关于输入源码解析的机制放在了第11章(ECMAScript Language: Lexical Grammar)中。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;从一道常见的面试题开始:&lt;br&gt;&lt;figure class=&quot;highlight javascript&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;
      
    
    </summary>
    
    
  </entry>
  
</feed>
