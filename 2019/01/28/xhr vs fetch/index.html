<!DOCTYPE html><html lang="ch"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> fetch返回一个promise，所以它在收到响应时直接进入微任务队列么？ · mg20</title><meta name="description" content="fetch返回一个promise，所以它在收到响应时直接进入微任务队列么？ - mg20"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://ginobilee.github.io/atom.xml" title="mg20"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ginobilee" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/blog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">fetch返回一个promise，所以它在收到响应时直接进入微任务队列么？</h1><div class="post-info">Jan 28, 2019</div><div class="post-content"><p>文章起源于 XHR(XMLHttpRequest) 与 Fetch 的比较。Fetch 的重大改变之一就是它返回一个 Promise，而在 XHR 中是利用回调的方式进行响应。XHR 响应后，会将对应的回调推入对应于网络请求的task(是一个macro task)中。而 Fetch 返回一个promise，浏览器会把 promise 的回调放入微任务中，那么是不是 Fetch 的响应也会更早的执行呢？   </p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>为了验证 Fetch 的回调是不是直接放入微任务中，我设计了这样一个实验：同时用fetch发出两个相同的请求，在其回调中，利用while循环阻塞一定时间，之后再直接resolve一个promise。如果fetch的回调直接放入微任务中，在前一个请求的响应被阻塞的时候，后一个响应应该也触发了，那么后一个响应的回调会直接进入微任务队列中，从而早于在前一个fetch回调中resolve的promise被执行。结果是不是这样呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = fetch(<span class="string">"http://baike.baidu.com/api/openapi/BaikeLemmaCardApi?scope=103&amp;format=json&amp;appid=379020&amp;bk_key=shoe&amp;bk_length=60"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = fetch(<span class="string">"http://baike.baidu.com/api/openapi/BaikeLemmaCardApi?scope=103&amp;format=json&amp;appid=379020&amp;bk_key=shoe&amp;bk_length=60"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span></span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="comment">// wait for 3 s</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p1 callback, before wait, and now is : "</span>, start)</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() &lt; start + <span class="number">5</span> * <span class="number">1000</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p1 callback, after wait, and now is : "</span>, start)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise initiated in p1 fire"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="comment">// wait for 3 s</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p2 callback, before wait, and now is : "</span>, start)</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() &lt; start + <span class="number">5</span> * <span class="number">1000</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p2 callback, after wait, and now is : "</span>, start)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise initiated in p2 fire"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// in p2 callback, before wait, and now is :  1548601804877</span></span><br><span class="line"><span class="comment">// in p2 callback, after wait, and now is :  1548601804877</span></span><br><span class="line"><span class="comment">// promise initiated in p2 fire</span></span><br><span class="line"><span class="comment">// in p1 callback, before wait, and now is :  1548601809880</span></span><br><span class="line"><span class="comment">// in p1 callback, after wait, and now is :  1548601809880</span></span><br><span class="line"><span class="comment">// promise initiated in p1 fire</span></span><br></pre></td></tr></table></figure></p>
<p>显然，输出并非如此，在首先响应的fetch的回调中，触发的promise仍然早于另外一个fetch的回调被调用了。<br>这样的结果显然跟 XHR 没有区别。那么是不是两个请求的响应时间差超过了3s呢？尝试加大<code>while</code>循环的时延后，表现仍然一如既往。</p>
<h3 id="对比-MutationObserver"><a href="#对比-MutationObserver" class="headerlink" title="对比 MutationObserver"></a>对比 MutationObserver</h3><p>MutationObserver 的回调也会放入微任务，它的表现会跟fetch一样么？<br>同样，为一个dom元素绑定两个监听事件，在其回调中触发一个微任务，观察触发顺序。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">'con'</span> <span class="attr">name</span>=<span class="string">'name'</span>&gt;</span>this is con<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> log = <span class="built_in">console</span>.log</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="keyword">function</span> <span class="title">cbFactory</span>(<span class="params">name</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">callback</span>(<span class="params">mutationList, observer</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">      mutationList.forEach(<span class="function">(<span class="params">mutation</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">switch</span>(mutation.type) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">case</span> <span class="string">'attributes'</span>:</span></span><br><span class="line"><span class="javascript">            log(<span class="string">'attribute change : '</span>, name)</span></span><br><span class="line"><span class="javascript">            <span class="built_in">Promise</span>.resolve().then(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">              log(<span class="string">'Promise: '</span>, name)</span></span><br><span class="line"><span class="undefined">            &#125;)</span></span><br><span class="line"><span class="javascript">            <span class="keyword">break</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">      &#125;);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> targetNode = <span class="built_in">document</span>.querySelector(<span class="string">"#con"</span>);</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> observerOptions = &#123;</span></span><br><span class="line"><span class="javascript">    attributes: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> observer = <span class="keyword">new</span> MutationObserver(cbFactory(<span class="number">1</span>));</span></span><br><span class="line"><span class="undefined">  observer.observe(targetNode, observerOptions);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> observe2 = <span class="keyword">new</span> MutationObserver(cbFactory(<span class="number">2</span>))</span></span><br><span class="line"><span class="undefined">  observe2.observe(targetNode, observerOptions)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  targetNode.attributes.removeNamedItem(<span class="string">'name'</span>)</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>结果如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">attribute change :  1</span><br><span class="line">attribute change :  2</span><br><span class="line">Promise:  1</span><br><span class="line">Promise:  2</span><br></pre></td></tr></table></figure></p>
<p>显然与浏览器中fetch表现不一致。看起来，MutationObserver 的回调是一个“干净”的微任务。<br>其实，这也很好理解。MutationObserver 是一个纯浏览器内事件，浏览器只需要在监听到事件发生后，将对应的回调推入微任务队列就可以了。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>到这里足可看出，fetch 不是一个单纯的promise。关键在于，fetch会发起一个网络请求，当请求被响应时，怎么通知主线程来处理回调? 在 XHR 中，是将回调放入对应于网络请求的任务队列中，fetch是否也是这样呢？<br>查找 WHATWG 的对应规范，其中确实提到收到响应后，会在网络请求的任务队列中推入任务:   </p>
<blockquote>
<p>Queue a task to run an operation on request’s client’s responsible event loop using the networking task source.</p>
</blockquote>
<p>即将task推入对应的event loop的网络请求任务队列中。</p>
<p>我推测fetch的工作模式实际上是:</p>
<ol>
<li>请求被响应，在网络请求任务队列中推入一个任务。这个任务应该是执行 enqueue promise的操作(虽然规范中并没有提到)</li>
<li>event loop执行到网络请求任务队列的该任务时，把对应promise的回调推入微任务</li>
<li>event loop在执行到当前循环的微任务检查点时执行该promise的响应</li>
</ol>
<p>即，对于fetch，其实浏览器还是沿用一样的网络请求处理逻辑，只是在响应时，推入对应任务队列的任务，执行了将promise回调推入微任务的动作。  </p>
<h3 id="搞清楚这个问题有什么用？"><a href="#搞清楚这个问题有什么用？" class="headerlink" title="搞清楚这个问题有什么用？"></a>搞清楚这个问题有什么用？</h3><p>在使用 xhr 时，在其回调中利用 promise 将任务放入微任务队列中，这个微任务一定会早于其它触发的 xhr 执行；如果对 fetch 上述模型不了解，会去想是否 fetch 中新触发的 promise 会晚于其它并发收到 fetch 的响应？在对处理顺序有要求的场合，这里就会影响到是否可以在回调中使用 promise 进行异步处理。搞清楚多个 fetch 的回调仍然会走 event loop 的多个loop，就明白是否会对程序的执行流产生影响。   </p>
<hr>

<p>ref:   </p>
<ol>
<li><a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noopener">Fetch Living Standard</a>   </li>
<li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">event loop in HTML</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/API/MutationObserver/MutationObserver" target="_blank" rel="noopener">MDN MutationObserver</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/blog/2019/01/28/webpack中异步加载的逻辑/" class="prev">PREV</a><a href="/blog/2019/01/25/我欲建立的知识结构模型/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 <a href="https://ginobilee.github.io">mg20</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>