<!DOCTYPE html><html lang="ch"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> fetch返回一个promise，所以它在收到响应时直接进入微任务队列么？ · mg20</title><meta name="description" content="fetch返回一个promise，所以它在收到响应时直接进入微任务队列么？ - mg20"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://ginobilee.github.io/atom.xml" title="mg20"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ginobilee" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/blog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">fetch返回一个promise，所以它在收到响应时直接进入微任务队列么？</h1><div class="post-info">Jan 28, 2019</div><div class="post-content"><p>文章起源于 XHR(XMLHttpRequest) 与 Fetch 的比较。Fetch 的重大改变之一就是它返回一个 Promise，而在 XHR 中是利用回调的方式进行响应。XHR 响应后，会将对应的回调推入对应于网络请求的task(是一个macro task)中。而 Fetch 返回一个promise，浏览器会把 promise 的回调放入微任务中，那么是不是 Fetch 的响应也会更早的执行呢？   </p>
<h3 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h3><p>为了验证 Fetch 的回调是不是直接放入微任务中，我设计了这样一个实验：同时用fetch发出两个相同的请求，在其回调中，利用while循环阻塞一定时间，之后再直接resolve一个promise。如果fetch的回调直接放入微任务中，在前一个请求的响应被阻塞的时候，后一个响应应该也触发了，那么后一个响应的回调会直接进入微任务队列中，从而早于在前一个fetch回调中新resolve的promise被执行。结果是不是这样呢？<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> p1 = fetch(<span class="string">"http://baike.baidu.com/api/openapi/BaikeLemmaCardApi?scope=103&amp;format=json&amp;appid=379020&amp;bk_key=shoe&amp;bk_length=60"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> p2 = fetch(<span class="string">"http://baike.baidu.com/api/openapi/BaikeLemmaCardApi?scope=103&amp;format=json&amp;appid=379020&amp;bk_key=shoe&amp;bk_length=60"</span>, &#123;</span><br><span class="line">  method: <span class="string">"POST"</span></span><br><span class="line">&#125;)</span><br><span class="line">p1.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="comment">// wait for 3 s</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p1 callback, before wait, and now is : "</span>, start)</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() &lt; start + <span class="number">5</span> * <span class="number">1000</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p1 callback, after wait, and now is : "</span>, start)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise initiated in p1 fire"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p2.then(<span class="function"><span class="params">response</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> start = <span class="built_in">Date</span>.now()</span><br><span class="line">  <span class="comment">// wait for 3 s</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p2 callback, before wait, and now is : "</span>, start)</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">Date</span>.now() &lt; start + <span class="number">5</span> * <span class="number">1000</span>) &#123;&#125;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"in p2 callback, after wait, and now is : "</span>, start)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="number">1</span>).then(<span class="function"><span class="params">v</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"promise initiated in p2 fire"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// in p2 callback, before wait, and now is :  1548601804877</span></span><br><span class="line"><span class="comment">// in p2 callback, after wait, and now is :  1548601804877</span></span><br><span class="line"><span class="comment">// promise initiated in p2 fire</span></span><br><span class="line"><span class="comment">// in p1 callback, before wait, and now is :  1548601809880</span></span><br><span class="line"><span class="comment">// in p1 callback, after wait, and now is :  1548601809880</span></span><br><span class="line"><span class="comment">// promise initiated in p1 fire</span></span><br></pre></td></tr></table></figure></p>
<p>显然，输出并非如此，在首先响应的fetch的回调中，触发的promise仍然早于另外一个fetch的回调被调用了。<br>这样的结果显然跟 XHR 没有区别。那么是不是两个请求的响应时间差超过了3s呢？尝试加大<code>while</code>循环的时延后，仍然不行。</p>
<h3 id="模拟一个单纯的promise的fetch"><a href="#模拟一个单纯的promise的fetch" class="headerlink" title="模拟一个单纯的promise的fetch"></a>模拟一个单纯的promise的fetch</h3><p>索性来模拟一个按照上述思路触发的fetch:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 模拟一个 纯 promise 的 fetch</span></span><br><span class="line"><span class="keyword">let</span> r = []</span><br><span class="line"><span class="keyword">const</span> fetch = <span class="function"><span class="keyword">function</span>(<span class="params">uri, options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resovle, reject</span>) </span>&#123;</span><br><span class="line">    r.push(resovle)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> f1 = fetch(<span class="string">"x"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise f1 fire: "</span>, res)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="string">"f1"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f1"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">const</span> f2 = fetch(<span class="string">"y"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">res</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"promise f2 fire: "</span>, res)</span><br><span class="line">  <span class="built_in">Promise</span>.resolve(<span class="string">"f2"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"f2"</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// after 100ms, f1 and f2 fires. note here they are fired in the 'same tick'</span></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  r.forEach(<span class="function"><span class="params">fn</span> =&gt;</span> &#123;</span><br><span class="line">    fn(<span class="number">1</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, <span class="number">100</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// result:</span></span><br><span class="line"><span class="comment">// promise f1 fire:  1</span></span><br><span class="line"><span class="comment">// promise f2 fire:  1</span></span><br><span class="line"><span class="comment">// f1</span></span><br><span class="line"><span class="comment">// f2</span></span><br></pre></td></tr></table></figure></p>
<p>在这段代码中，我以一种纯粹promise的方式模拟fetch的行为。这样两个fetch在100ms后被同时resolve，于是先后进入微任务队列；而在首先执行的回调中触发的promise，确实会晚于另一个fetch的回调执行。   </p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>到这里足可看出，fetch绝不是如模拟代码中的一个单纯的promise。关键在于，fetch会发起一个网络请求，当请求被响应时，怎么通知主线程来处理回调? 在 XHR 中，是将回调放入对应于网络请求的任务队列中，fetch是否也是这样呢？<br>查找 WHATWG 的对应规范，其中确实提到收到响应后，会在网络请求的任务队列中推入任务:   </p>
<blockquote>
<p>Queue a task to run an operation on request’s client’s responsible event loop using the networking task source.</p>
</blockquote>
<p>即将task推入对应的event loop的网络请求任务队列中。至此可以认为，fetch的工作模式实际上是:</p>
<ol>
<li>请求被响应，在网络请求任务队列中推入一个任务。这个任务应该是执行 enqueue promise的操作(虽然规范中并没有提到)</li>
<li>主线程的event loop执行到网络请求任务队列的该任务时，把对应promise的回调推入微任务</li>
<li>主线程的event loop在执行到当前循环的微任务检查点时执行该promise的响应</li>
</ol>
<p>如此，说明从event loop的执行流程上，xhr 与 fetch的差别其实不大。两者都会首先通过网络请求的宏任务来触发。</p>
<hr>

<h3 id="搞清楚这个问题有什么用？"><a href="#搞清楚这个问题有什么用？" class="headerlink" title="搞清楚这个问题有什么用？"></a>搞清楚这个问题有什么用？</h3><p>在使用 xhr 时，在其回调中利用 promise 将任务放入微任务队列中，这个微任务一定会早于其它触发的 xhr 执行；如果对 fetch 上述模型不了解，会去想是否 fetch 中新触发的 promise 会晚于其它并发收到 fetch 的响应？在对处理顺序有要求的场合，这里就会影响到是否可以在回调中使用 promise 进行异步处理。搞清楚多个 fetch 的回调仍然会走 event loop 的多个loop，就明白是否会对程序的执行流产生影响。   </p>
<hr>

<p>ref:   </p>
<ol>
<li><a href="https://fetch.spec.whatwg.org/" target="_blank" rel="noopener">Fetch Living Standard</a>   </li>
<li><a href="https://html.spec.whatwg.org/multipage/webappapis.html#event-loop-processing-model" target="_blank" rel="noopener">event loop in HTML</a></li>
</ol>
</div></article></div></main><footer><div class="paginator"><a href="/blog/2019/01/25/我欲建立的知识结构模型/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 <a href="https://ginobilee.github.io">mg20</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>