<!DOCTYPE html><html lang="ch"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> How chrome works?(part1) · mg20</title><meta name="description" content="How chrome works?(part1) - mg20"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://ginobilee.github.io/atom.xml" title="mg20"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ginobilee" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/blog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">How chrome works?(part1)</h1><div class="post-info">Jan 29, 2019</div><div class="post-content"><h3 id="功能结构-进程-线程视角"><a href="#功能结构-进程-线程视角" class="headerlink" title="功能结构(进程/线程视角)"></a>功能结构(进程/线程视角)</h3><p>chrome采用多进程结构:</p>
<ol>
<li>主进程(也称为browse进程或browser)，它主要执行:<ol>
<li>运行 UI</li>
<li>管理 tab(renderer) 和 插件进程</li>
<li>部分与操作系统的交互，如I/O</li>
</ol>
</li>
<li>renderer进程(后面也称为renderer)，即渲染进程，可以认为对应于每个tab有一个renderer进程。renderer进程使用Blink布局引擎来对 HTML/CSS/脚本 进行解析和布局，chrome会为每个renderer进程实例化一个Blink引擎实例。</li>
</ol>
<blockquote>
<p> (Blink) The web engine responsible for turning HTML, CSS and scripts into paint commands and other state changes. </p>
</blockquote>
<p>架构图1(来自谷歌):<br><img src="https://raw.githubusercontent.com/ginobilee/blog/master/source/images/chrome-structure-1.png"><br>图中以(process boundary)为边界分为上下三层，上三层属于browser进程；下三层是renderer进程。</p>
<h4 id="browser进程"><a href="#browser进程" class="headerlink" title="browser进程"></a>browser进程</h4><p>browser进程管理各个renderer进程，renderer进程之间是相互隔离的，每个render进程对于系统的访问也受browser限制，这是为了安全和性能的考虑。  </p>
<p>browser进程内主要维护两个线程(不止): 主线程(main thread)和I/O线程。  </p>
<p>I/O线程主要负责: </p>
<ol>
<li>与系统I/O交互，如网络请求</li>
<li>与renderer通信。I/O线程会为每一个renderer维护一个IPC::Channel，它来负责renderer与browser之间的通信。  </li>
</ol>
<p>main thread是执行绘制的主体，图1中上三层，主要就是它的工作。可以看到从上到下分为三层:</p>
<ol>
<li>Browser: Represents the browser window, it contains multiple WebContentses.(代表浏览器窗口，包含多个 WebContentses </li>
<li>WebContents: A reusable component that is the main class of the Content module. It’s easily embeddable to allow multiprocess rendering of HTML into a view.<blockquote>
<p>WebContents represents the contents of a webpage. It is the top-level object in the content module, and has the responsibility of displaying a web page in a rectangular view.</p>
</blockquote>
</li>
<li>Renderer / Render host: This is Chromium’s “multi-process embedding layer.” It proxies notifications and commands across the process boundary.(相当于多个renderer进程在browser中的代理)</li>
</ol>
<p>browser进程示意(来自谷歌):<br><img src="https://raw.githubusercontent.com/ginobilee/blog/master/source/images/chrome-renderer-process.png"></p>
<h4 id="renderer进程"><a href="#renderer进程" class="headerlink" title="renderer进程"></a>renderer进程</h4><p>每个renderer进程维护两个线程: main thread和render thread(当提到renderer时总是指进程，线程用render thread区分)。</p>
<p>main thread 主要负责对browser通信</p>
<p>render thread 执行渲染(并非在屏幕上绘制，那是browser进程的工作。这里指 render tree的管理。)的工作，这个线程的实体应该就是前述Blink的实例。它应该是常说的event loop的运行实体，包含两个重要的部分: 渲染引擎与js引擎。</p>
<p>renderer的main thread的作用之一是在render thread与browser进行同步交互时对于其它消息的保存。例如脚本中通过<code>document.cookie</code>获取cookie，请求通过main thread发送给browser(browser进程的CookieMonster对象管理着cookie)，同时该render thread的操作会暂停(同步请求，相当于event loop停住了)；等到browser将结果传回来，render再恢复运行。在render线程阻塞的过程中renderer收到的消息，都被main thread所缓存，在render线程收到cookie请求后再依次传给render thread。  </p>
<p>renderer进程示意(来自谷歌):<br><img src="https://raw.githubusercontent.com/ginobilee/blog/master/source/images/chrome-renderer-process.png"></p>
<h4 id="renderer与browser的交互"><a href="#renderer与browser的交互" class="headerlink" title="renderer与browser的交互"></a>renderer与browser的交互</h4><p>每个renderer中会维护一个全局的(对该进程而言) RenderProcess 对象，它与 browser 进程进行通信，并维护全局状态。针对每个renderer，browser维护一个对应的 RenderProcessHost ，它来维护browser的相关状态，并与renderer通信。<br>RenderViewHost 和 RenderWidgetHost (browser进程) 可以认为是 RenderView 和 RenderWidget （renderer进程的render线程内)的代理。<br>交互主要对接在图1中的中间两层。  </p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以点击事件为例。如果我们在鼠标点击事件上上绑定了回调，回调中发起了一个网络请求，那么处理的流程应该就是:</p>
<ol>
<li>browser管理的ui线程收到click事件，将其发给renderer</li>
<li>renderer收到事件后，会将对应的回调推入对应的任务队列；当event loop有空时，开始调用js engine执行此任务(这里还可以更详细，event loop与js engine的运行逻辑)；js engine执行，发出网络请求；renderer将此请求发给browser的I/O线程</li>
<li>browser通过I/O线程调用系统I/O发起请求</li>
<li>browser收到响应后，将response回传renderer。于是renderer像处理click事件一样，将其推入对应的任务队列，等待event loop调起js engine执行。</li>
</ol>
<blockquote>
<p>Each request(已经到了browser管理中) is then converted into a URLRequest object, which in turn forwards it to its internal URLRequestJob that implements the specific protocol desired. When the URLRequest generates notifications, its ResourceDispatcherHost::Receiver and request ID are used to send the notification to the correct RenderProcessHost for sending back to the renderer. </p>
</blockquote>
<h3 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h3><ol>
<li>Blink 与 Webkit 的角色一样么？区别是什么？<br>角色一样。区别？</li>
<li>WebContents 层的引擎是什么，是不是重绘总是发生在 renderer 进程中，所以会影响性能；而css的transform的改变发生在browser的WebContents层，所以不会影响性能？</li>
<li>event loop的一个loop可以认为是render thread内的一次循环标志了一个loop。一个渲染帧呢？比如会触发 requestAnimationFrame 回调 的一个帧，对于chrome来说以什么标志一个帧，或者说是帧之间的边界？</li>
<li>总结完后再去看<a href="https://chromium.googlesource.com/chromium/src/+/master/docs/threading_and_tasks.md" target="_blank" rel="noopener">Threading and Tasks in Chrome</a>，感觉这里参考的三篇文档只是一个抽象的描述，具体实现要复杂的多。加油  </li>
</ol>
<h3 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h3><p><a href="https://www.chromium.org/developers/design-documents/multi-process-resource-loading" target="_blank" rel="noopener">Multi-process Resource Loading</a><br><a href="https://www.chromium.org/developers/design-documents/displaying-a-web-page-in-chrome" target="_blank" rel="noopener">How Chromium Displays Web Pages</a><br><a href="https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code" target="_blank" rel="noopener">Getting Around the Chromium Source Code Directory Structure</a></p>
</div></article></div></main><footer><div class="paginator"><a href="/blog/2019/01/28/webpack中异步加载的逻辑/" class="next">NEXT</a></div><div class="copyright"><p>© 2019 <a href="https://ginobilee.github.io">mg20</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>