### bfs 通用算法
```
function bfs(g) {
  const queue = []
  visited[g] = true
  enqueue(queue, g)
  while(!isEmpty(queue)) {
    const v = dequeue(queue)
    for(w = v 的邻接点;...;) {
      if (!visited[w]) {
        visited[w] = true
        enqueue(queue, w)
      }
    }
  }
}
```

### dfs 通用算法
// 递归
```
function dfs(g) {
  // 将当前节点置为已访问，然后遍历其邻接点，调用同样算法
  visited[g] = true
  for (w = g.临界点;...;) {
    if (!visited[w]) {
      dfs(w)
    }
  }
}
```

// 非递归
```
function dfs(g) {
  const stack = new Stack()
  visited[g] = true
  stack.push(g)
  // g.list 是 g 的邻接表，g.uc = g.unvisitedChild 是它尚未被访问的邻接点。在一个顶点入栈的时候创建其 uc指针
  g.uc = g.list

  /* 当入栈或出栈一个元素的时候，完成一次循环。
     在一次循环内，访问栈顶节点的邻接表，直到邻接表为空或者找到一个未访问过的元素并入栈之
  */
  while(!isEmpty(stack)) {
    vertex c = stack.top()
    vertex n = c.uc
    while(n && visited[n]) {
      n = n.next
    }
    if (!n) {// 如果邻接表都被访问过了
      stack.pop()
    } else { // 有未被访问的元素
      c.uc = n.next // 更新当前栈顶元素的未被访问邻接点指针
      // 入栈该邻接点
      visited[n] = true
      n.uc = n.list
      stack.push(n)
    }
  }
}
```
### 最短路径问题
dijkstra 算法  
点s到d的最短距离   
思路：从点s开始遍历其邻接点，选择最小者v添加入集合stack，同时查看v的邻接点w：若w未加入stack且 `dist[v] + e(v, w) < = dist[w]`，则更新dist[w]。然后进入下一轮循环，再选择 dist 最小者。  
dist应为点w到s的距离还是到stack中任一点的直接距离？应该为前者，因为找的是s到d的最短距离，所以要以这个距离来度量。

```
function dijkstra(g) {
  const stack = new Stack()
  stack.push(g)
  visited[g] = true
  const dist = new MinStack() // 距离应该是一个最小堆
  while(!isEmpty(dist)) { // 循环的边界是什么？未收录顶点堆为空，或者在剩下的顶点中，dist取不到最小值(也即图非连通)
    // 每次循环要做什么？1. 选择visited为false的dist最小者v；2. visited[v] = true; 3. 便利v的邻接点w，如果w没有被浏览过，更新其dist。这一步就会操作dist，从而影响1的选择
    // 什么时候跳出？当最小堆为空
    const v = dist.pop()
    // 这里需要判断v的dist是否为无穷大,这时图不连通
    if (dist[v] === 无穷大) {
      break;
    }
    for(w = v.邻接点;...;...) {
      if (!visited[w]) {
        if ((dist[v] + e(v, w)) < dist[w]) {
          parent[w] = v
          dist[w] = dist[v] + e(v, w)
        }
      }
    }
  }
}
```

### 多个源到终点的距离
floy算法  
使用一个与邻接矩阵一样规模的矩阵进行保存每个顶点到另外一个顶点的距离，初始化时点a到其直接相邻点的距离为其对应边权重，到其非相邻顶点的距离为无穷大。  
这个矩阵相当于当路径上没有任何中间节点(也就是中间节点集为空)时所有顶点之间的距离。  
然后开始依次放入每个节点。放入一个节点后，更新前述矩阵，通过查看节点a，b到新加入节点k的距离，来更新节点a，b之间的距离。  
当将所有节点都放入了中间节点集，此时的矩阵记录的就是最后得到的最短距离。  

### 最小生成树问题
#### 什么是最小生成树
1. 包含所有顶点，只有 (顶点数 - 1) 条边，且无回路
2. 边的权重和最小
3. 特性: 向树中添加任一条边都会形成回路

#### prim 算法
它的思路是遍历没有进入 已收录节点集，查看其最小路径。将最小路径的节点v收录进来，同时更新其所有未收录的邻接点w...，如果w到v的距离小于dist[w](这是v收录进去之前w到已收录节点集的最小距离)，更新dist[w] = E(v, w)；下一次循环时，再在所有未被收录进去的节点中选择 dist 最小者。 
dist 的初始值应该是被收入顶点到其它节点的直接距离，若不相邻则为无穷大。任一节点进入被收录集后s，对于未被收录的节点来说，他们之间的差异就抹消了：未被收录节点到s的距离是它到s中任何一个直接相邻点的直接距离，若s中没有它的直接相邻点，那么距离为无穷大。  

本来prim算法的思路是，遍历***剩下边中权重最小者***；通过为每个节点记录 dist，就可以在每次循环时***遍历未被收录的节点***，然后取最小者。这同时满足了两个约束: 1. 下一条边不能形成回路(遍历未被收录的点，就不会形成回路)；2. 用 dist 记录顶点到s中任一节点的直线距离的最小者，如此可以保证选到当前不会形成回路的最小边。  
遍历节点，当然比遍历边要简单方便多了。   

树或者说前述 s 应该怎么存？  
就用数组，依次存储进入 s 的节点。每个节点更新 dist 时记录当前邻接点，如此可以知道到达该点的边。这样就形成了一棵树(不一定是二叉树)，树的存储形式是节点记录了其父节点。  
更好的办法是用一个单独的数据结构来记录这个父节点信息，比如 parent[] 数组。这样也不用将信息记录在每个节点上，前者还要改数据结构(毕竟只有js这样的动态语言修改结构才比较方便)。  

#### kruskal 算法
思路:  真的每次遍历边，选择权重最小且不构成回路者。  
关键点:
1. 如何选择权重最小的边？遍历或排序的性能开销都比较大，但可以使用最小堆，如此就是 O(logE) 的复杂度。  

#### prim vs kruskal
1. prim 其实是从定点出发，选择边，因此时间复杂度为 O(V的平方)。对于稠密图比较适合。
2. kruskal 其实是从边出发，应用最小堆来实现边搜索的化，时间复杂度为 O(E*log(E))。对于稀疏图比较有效(稠密图边比较多)
3. 所以决定使用哪种算法是判断图的稠密程度。

### 贪心算法
是什么？
1. 每一步都要最 好 的
2. 如何定义 好 ？
3. 需要满足一些约束条件


### 关键路径问题
1. 如果某个路径可以缩短时间，整个项目可以提前完工？
    1. 需要该路径既是关键路径，还必须是所有关键路径必经的路径。