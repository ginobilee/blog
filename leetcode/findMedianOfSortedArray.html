<!DOCTYPE html><html lang="ch"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> leetcode-寻找数组的中位数 · mg20</title><meta name="description" content="leetcode-寻找数组的中位数 - mg20"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon.png"><link rel="stylesheet" href="/blog/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="https://ginobilee.github.io/atom.xml" title="mg20"></head><body><div class="wrap"><header><a href="/blog/" class="logo-link"><img src="/blog/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/blog/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/blog/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ginobilee" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/blog/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">leetcode-寻找数组的中位数</h1><div class="post-info">Jan 25, 2019</div><div class="post-content"><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><p>两个有序数组，如何在时间复杂度为<code>O(log(m+n))</code>的条件下寻找到将其有序合并后数组的中位数？</p>
<p>这道题的最优解有三个关键点:</p>
<ol>
<li>意识到寻找中间点，就是将有序数组拆分为等长的两段，拆分点就是中间点。所以对于两个有序数组，寻找他们合起来的中间点就是分别将两个数组拆分成两段，左边段加起来的长度等于右边段的长度，这样能保证是中间位置；其次保证左边段的末位断点小于右边段的起始端点，则保证了数组合并的拆分点是有序数组的中间点。</li>
<li>要将分支条件梳理清楚。如满足题意的中间点的条件实际是 <code>(i=0 || j=n || A[i-1]&lt;=B[j])&amp;&amp;(j=0 || i=m || B[j-1]&lt;=A[j])</code> // m&lt;=n。我可以想到要保证端点值大小约束的条件，但对于边界条件如 i=0,i=m… 如何融入进去没有思考清楚。没有思考清楚的原因是也没有去真正细致地把这些条件写出来，而是一想到有这么多边界条件就嫌麻烦，想找捷径；而这里却是真正把所有问题列出来，写写画画，才能把问题看得更清楚的必须路径。即便有麻烦的边界，还是依次把其写出来，去对比思考，才更容易看清楚它的本质。<ol>
<li>当有了上述条件，就可以找到它的反条件。把 || 和 &amp;&amp; 想成数学上的集合的并与交，即可以推导出它的反条件: <code>!((i=0 || j=n || A[i-1]&lt;=B[j])&amp;&amp;(j=0 || i=m || B[j-1]&lt;=A[j])) &lt;==&gt; (!(i=0 || j=n || A[i-1]&lt;=B[j]) || !(j=0 || i=m || B[j-1]&lt;=A[j])) &lt;==&gt; ((!(i=0) &amp;&amp; !(j=n) &amp;&amp; !(A[i-1]&lt;=B[j])) || (!(j=0) &amp;&amp; !(i=m) &amp;&amp; !(B[j-1]&lt;=A[j]))) &lt;==&gt; ((i&gt;0 &amp;&amp; j&lt;n &amp;&amp; A[i-1]&gt;B[j]) || (j&gt;0 &amp;&amp; i&lt;m &amp;&amp; B[j-1]&gt;A[j]))</code></li>
<li>注意上述推导中最后一步，取 <code>i=0</code>的非时，因为i不会小于0，所以直接为<code>i&gt;0</code>。</li>
<li>至此，就可以将整个算法的分支写为: <ol>
<li><code>if(i&gt;0 &amp;&amp; j&lt;n &amp;&amp; A[i-1]&gt;B[j])</code></li>
<li><code>else if(j&gt;0 &amp;&amp; i&lt;m &amp;&amp; B[j-1]&gt;A[j])</code></li>
<li><code>else{// 找到了匹配的i,j，但i,j可能为边界值。没有关系，只要在计算中位值时注意就可以了}</code></li>
<li>至此，算法的逻辑已经很清晰了。</li>
</ol>
</li>
</ol>
</li>
<li>最后一点是，在<code>m&lt;=n</code>的条件中，<code>i&gt;0</code>与<code>j&lt;n</code>是等价的。如此前述2.3.1和2.3.2中的条件都是可以简写的。具体推导就不写了。关键在于充分利用前提条件<code>m&lt;=n</code>，而自己就忽略了这个条件。</li>
</ol>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">function findMedian2(nums1, nums2) &#123;</span><br><span class="line">  let shorter = nums1, longer = nums2, m = nums1.length, n = nums2.length</span><br><span class="line">  if (m &gt; n) &#123;</span><br><span class="line">    shorter = nums2</span><br><span class="line">    longer = nums1</span><br><span class="line">    temp = n</span><br><span class="line">    n = m</span><br><span class="line">    m = temp</span><br><span class="line">  &#125;</span><br><span class="line">  let iMin = 0, iMax = m, halfLength = Math.floor((m + n + 1) / 2)</span><br><span class="line">  while (iMin &lt;= iMax) &#123;</span><br><span class="line">    const i = Math.floor((iMin + iMax) / 2)</span><br><span class="line">    const j = halfLength - i</span><br><span class="line">    if (i &lt; iMax &amp;&amp; longer[j - 1] &gt; shorter[i]) &#123;</span><br><span class="line">      // i is small</span><br><span class="line">      iMin = i + 1</span><br><span class="line">    &#125; else if (i &gt; iMin &amp;&amp; shorter[i - 1] &gt; longer[j]) &#123;</span><br><span class="line">      // i is big</span><br><span class="line">      iMax = i - 1</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      let maxLeft = 0</span><br><span class="line">      if (i === 0) &#123;</span><br><span class="line">        maxLeft = longer[j - 1]</span><br><span class="line">      &#125; else if (j === 0) &#123;</span><br><span class="line">        maxLeft = shorter[i - 1]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        maxLeft = Math.max(shorter[i - 1], longer[j - 1])</span><br><span class="line">      &#125;</span><br><span class="line">      if ((m + n) % 2 === 1) return maxLeft</span><br><span class="line"></span><br><span class="line">      let minRight = 0</span><br><span class="line">      if (i === m) &#123;</span><br><span class="line">        minRight = longer[j]</span><br><span class="line">      &#125; else if (j === n) &#123;</span><br><span class="line">        minRight = shorter[i]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        minRight = Math.min(shorter[i], longer[j])</span><br><span class="line">      &#125;</span><br><span class="line">      return (maxLeft + minRight) / 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return 0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="自己的初始思路"><a href="#自己的初始思路" class="headerlink" title="自己的初始思路"></a>自己的初始思路</h3><p>自己也想出了一个思路，只是代码写起来非常复杂和容易出错，且算法复杂度应该是 <code>O(log(m)log(n))</code> 的。不过自己也花了很大的心思写出来了，还是值得记录一下的。<br>思路就是，在两个数组出现交叉时，寻找开始端点较大者在对方数组的插入位置: </p>
<ol>
<li>若此位置大于所要的中间位数(它是固定的)，则中间点必在对方数组中，根据所要中位数下标即可找到</li>
<li>若此位置等于所要的中间位数，则他就是要找的中间点，再通过比较两个数组的下一个节点大小，即可找到</li>
<li>若此位置小于所要的中间位数，则取对方数组的(所找到的插入位置的下一个)元素为待查找元素，反过来在自己的数组中，从刚才的查找元素之后开始查找，再取比较其相对位置与中位数所需的相对位置的偏差，即进入下一个循环。</li>
</ol>
<p>这样如果在查找时用二分查找，那么效率是 <code>O(log(searchlength))</code> 的。而进行查找的个数，因为是对方分片查找导致的，也可以认为是 <code>O(log(length))</code>。所以可以视整体复杂度为 <code>O(log(m)log(n))</code>。<br>这道题自己可以把自己的思路坚持写出来，并通过测试集，击败将近 50% 的同语言算法，还是不错的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line">var findMedianSortedArrays = function(nums1, nums2) &#123;</span><br><span class="line">  function getMedian(arr, idxOfMid) &#123;</span><br><span class="line">    const l = arr.length</span><br><span class="line">    if (l % 2 === 1) &#123;</span><br><span class="line">      return arr[idxOfMid]</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return (arr[idxOfMid] + arr[idxOfMid - 1]) / 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // if one is empty</span><br><span class="line">  const arr1 = nums1,</span><br><span class="line">    arr2 = nums2</span><br><span class="line">  if (nums1.length === 0 || nums2.length === 0) &#123;</span><br><span class="line">    let noneEmptyArr = arr1.length === 0 ? arr2 : arr1</span><br><span class="line">    const l = noneEmptyArr.length</span><br><span class="line">    const idx1 = Math.floor(l / 2)</span><br><span class="line">    return getMedian(noneEmptyArr, idx1)</span><br><span class="line">  &#125;</span><br><span class="line">  // if one&apos;s end is little than another&apos;s start</span><br><span class="line">  const l = arr1.length + arr2.length</span><br><span class="line">  const arr1LittleThanArr2 = !(arr1[arr1.length - 1] &gt; arr2[0])</span><br><span class="line">  const arr2LittleThanArr1 = !(arr2[arr2.length - 1] &gt; arr1[0])</span><br><span class="line">  if (arr1LittleThanArr2 || arr2LittleThanArr1) &#123;</span><br><span class="line">    const littleOne = arr1LittleThanArr2 ? arr1 : arr2,</span><br><span class="line">      biggerOne = arr1LittleThanArr2 ? arr2 : arr1</span><br><span class="line">    const idx1 = Math.floor(l / 2)</span><br><span class="line">    if (l % 2 === 1) &#123;</span><br><span class="line">      if (idx1 &lt; littleOne.length) &#123;</span><br><span class="line">        return littleOne[idx1]</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        return biggerOne[idx1 - littleOne.length]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      const m1 = idx1 &lt; littleOne.length ? littleOne[idx1] : biggerOne[idx1 - littleOne.length]</span><br><span class="line">      const idx2 = idx1 - 1</span><br><span class="line">      const m2 = idx2 &lt; littleOne.length ? littleOne[idx2] : biggerOne[idx2 - littleOne.length]</span><br><span class="line">      return (m1 + m2) / 2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  // has inter items</span><br><span class="line">  // prepare for first lookup</span><br><span class="line">  let target = arr1[0] &lt; arr2[0] ? arr1 : arr2,</span><br><span class="line">    another = arr1[0] &lt; arr2[0] ? arr2 : arr1</span><br><span class="line">  // idxLE: indexOfLookupElement, ssIdx: searchStartIndex, idxTBS: idxToBeSearched</span><br><span class="line">  let idxLE = 0,</span><br><span class="line">    e = another[idxLE],</span><br><span class="line">    ssIdx = 0,</span><br><span class="line">    idxTBS = Math.floor(l / 2)</span><br><span class="line">  if (l % 2 === 0) &#123;</span><br><span class="line">    idxTBS -= 1</span><br><span class="line">  &#125;</span><br><span class="line">  while (true) &#123;</span><br><span class="line">    // iPos: interplationPosition, the biggest position &apos;e&apos; can be interplated in target</span><br><span class="line">    let iPos = findLastPos(target, ssIdx, target.length - 1, e)</span><br><span class="line">    // relL: relative length</span><br><span class="line">    const relL = iPos - ssIdx</span><br><span class="line">    if (relL &gt; idxTBS) &#123;</span><br><span class="line">      const m1 = target[ssIdx + idxTBS]</span><br><span class="line">      if (l % 2 === 1) &#123;</span><br><span class="line">        return m1</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        const m2 = target.length &gt; ssIdx + idxTBS + 1 ? (target[ssIdx + idxTBS + 1] &gt; e ? e : target[ssIdx + idxTBS + 1]) : e</span><br><span class="line">        return (m1 + m2) / 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (relL === idxTBS) &#123;</span><br><span class="line">      if (l % 2 === 1) &#123;</span><br><span class="line">        return e</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        idx2 = another[idxLE + 1]</span><br><span class="line">        const m2 = target.length &gt; ssIdx + idxTBS ? (target[ssIdx + idxTBS] &gt; idx2 ? idx2 : target[ssIdx + idxTBS]) : idx2</span><br><span class="line">        return (e + m2) / 2</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // // &apos;another&apos; has no elements need to search any more</span><br><span class="line">      if (idxLE === another.length - 1) &#123;</span><br><span class="line">        const idx1 = idxTBS + ssIdx - 1</span><br><span class="line">        if (l % 2 === 1) &#123;</span><br><span class="line">          return target[idx1]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return (target[idx1] + target[idx1 + 1]) / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (iPos === target.length) &#123;</span><br><span class="line">        // &apos;target&apos; has no more elements to search</span><br><span class="line">        const idx1 = idxLE + relL</span><br><span class="line">        if (l % 2 === 1) &#123;</span><br><span class="line">          return another[idx1]</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          return (another[idx1] + another[idx1 + 1]) / 2</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        ssIdx = idxLE + 1</span><br><span class="line">        idxTBS = idxTBS - relL - 1</span><br><span class="line">        idxLE = iPos</span><br><span class="line">        // switch target and another</span><br><span class="line">        const temp = target</span><br><span class="line">        target = another</span><br><span class="line">        another = temp</span><br><span class="line">        e = another[idxLE]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(&quot;error&quot;)</span><br><span class="line">  function findLastPos(arr, start, end, item) &#123;</span><br><span class="line">    const mid = Math.floor((end + start) / 2)</span><br><span class="line">    if (start &gt;= arr.length) &#123;</span><br><span class="line">      return arr.length - 1</span><br><span class="line">    &#125;</span><br><span class="line">    if (start &gt; end) &#123;</span><br><span class="line">      return start</span><br><span class="line">    &#125;</span><br><span class="line">    if (arr[mid] &lt; item) &#123;</span><br><span class="line">      start = mid + 1</span><br><span class="line">      if (start &gt;= arr.length) &#123;</span><br><span class="line">        return start</span><br><span class="line">      &#125;</span><br><span class="line">      return findLastPos(arr, start, end, item)</span><br><span class="line">    &#125; else if (arr[mid] === item) &#123;</span><br><span class="line">      let cur = mid</span><br><span class="line">      while (arr[++cur] === item) &#123;&#125;</span><br><span class="line">      return cur</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      end = mid - 1</span><br><span class="line">      if (end &lt; 0) &#123;</span><br><span class="line">        return 0</span><br><span class="line">      &#125;</span><br><span class="line">      return findLastPos(arr, start, end, item)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div></main><footer><div class="paginator"></div><div class="copyright"><p>© 2019 <a href="https://ginobilee.github.io">mg20</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>